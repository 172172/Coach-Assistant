// /api/chat.js
const KNOWLEDGE_URL = "https://raw.githubusercontent.com/172172/Coach-Assistant/main/assistant-knowledge.txt";
const CACHE_MS = 5 * 60 * 1000;

let knowledgeCache = { text: null, fetchedAt: 0 };

async function getKnowledge() {
  const now = Date.now();
  if (knowledgeCache.text && now - knowledgeCache.fetchedAt < CACHE_MS) return knowledgeCache.text;
  const res = await fetch(KNOWLEDGE_URL, { cache: "no-store" });
  if (!res.ok) throw new Error(`Misslyckades hämta kunskap: ${res.status}`);
  const text = await res.text();
  knowledgeCache = { text, fetchedAt: now };
  return text;
}

// ---------- helpers ----------
function normalize(s = "") {
  return s.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/ö/g,"o").replace(/ä/g,"a").replace(/å/g,"a")
    .replace(/\s+/g," ").trim();
}
function isSortbyteQuery(msg = "") {
  const t = normalize(msg);
  return /(sort\s*byte|sortbyte|byta sort|byte i tappen|sortbyten?)/.test(t);
}
function hasTypeHint(msg = "") {
  const t = normalize(msg);
  return /(ol|lager|ale|stout|ipa|lask|soda|vatten|juice|cider|energi|sirap|syrup|smak|kolsyrad|still)/.test(t);
}
function extractTypePair(msg = "") {
  const t = normalize(msg);
  const m = t.match(/(?:fran\s+)?([a-z0-9\-]+)\s*(?:->|→|till)\s*([a-z0-9\-]+)/i);
  if (m) return { from: m[1], to: m[2], hasPair: true };
  return { from: null, to: null, hasPair: false };
}
// Plocka ut rubriker ur manualen (endast själva rubrikraden, inte innehåll)
function extractHeadings(knowledgeText) {
  const lines = knowledgeText.split(/\r?\n/);
  const heads = [];
  for (const ln of lines) {
    if (/^\s*#{2,}\s+/.test(ln) || /^\s*[-*]\s*Avsnitt:/i.test(ln) || /^\s*Avsnitt:/i.test(ln)) {
      const h = ln.replace(/^\s*[-*]\s*/,'').trim();
      if (h) heads.push(h);
    }
  }
  // fallback: även rader med "Avsnitt:" mitt i
  if (heads.length < 3) {
    for (const ln of lines) {
      if (/Avsnitt\s*:/.test(ln)) heads.push(ln.trim());
    }
  }
  // dedupe + begränsa
  return [...new Set(heads)].slice(0, 200);
}
function relevantHeadings(headings) {
  const kw = /(sort|byte|tapp|tappa|fyll|cip|skolj|flush|omkoppl|vaxl|rengor|sanit)/i;
  return headings.filter(h => kw.test(h)).slice(0, 12);
}

export default async function handler(req, res) {
  try {
    if (req.method !== "POST") return res.status(405).json({ error: "Only POST allowed" });

    const { message = "", prev = null } = req.body || {};
    const knowledge = await getKnowledge();

    const sortIntent = isSortbyteQuery(message);
    const typeHint = hasTypeHint(message);
    const pair = extractTypePair(message);
    const allHeadings = extractHeadings(knowledge);
    const relHeadings = relevantHeadings(allHeadings);

    // --- SYSTEM ---
    const system = `
Du är "Coach Assistant" – mentor på produktionslinjen (t.ex. Linje 65).
Ton: varm, lugn, naturlig, pedagogisk. Tala som till en kollega.

ABSOLUT:
- Råd måste stödas av "Kunskap" (manual).
- Svara i EXAKT JSON enligt schemat. Ingen text utanför JSON.
- Hårt stopp endast vid mycket låg täckning (<0.25) och inga relevanta rubriker.

DIALOG:
- Vid vag fråga: ställ EN tydlig följdfråga (öppen). Inga påhittade alternativ om manualen inte listar dem.
- "spoken" ska låta mänskligt och erbjuda stegvis guidning (“säg till så tar vi nästa del”).

SORTBYTE:
- Om typ saknas: be med öppen fråga: "Vilken produkt går du från – och till?"
- När typ finns: ge lugna, numrerade steg (förberedelser, säkringar, switch/flush/CIP om manualen nämner det, kontroller, återstart).
  * Sikta på 8–20 steg om manualen tillåter.
  * Lista exakta rubrikträffar i "matched_headings".
  * Inga egna siffror/parametrar: använd generella formuleringar om manualen saknar värden.

COVERAGE-KALIBRERING (sätt rimlig siffra – inte för låg när rubriker matchar):
- ≥0.75: flera starka rubriker direkt relevanta.
- 0.6–0.75: delvis stöd; generella formuleringar OK.
- 0.4–0.6: viss relevans; leverera steg men uppmana att verifiera mot rubrikerna.
- <0.25: för svagt → ingen detaljerad vägledning.

JSON-SCHEMA:
{
  "spoken": string,
  "need": { "clarify": boolean, "question"?: string, "options"?: string[] },
  "cards": {
    "summary": string,
    "steps": string[],
    "explanation": string,
    "pitfalls": string[],
    "simple": string,
    "pro": string,
    "follow_up": string,
    "coverage": number,
    "matched_headings": string[]
  },
  "follow_up": string
}
`.trim();

    // --- USER ---
    const user = `
Kunskap (manual – fulltext):
"""
${knowledge}
"""

Rubrikindex (för referens – använd dessa strängar för "matched_headings" när relevant):
- ${allHeadings.join("\n- ")}

Relevanta rubriker (extra fokus):
- ${relHeadings.join("\n- ")}

Användarens inmatning:
"${message}"

Typ-hint:
${pair.hasPair ? `${pair.from} → ${pair.to}` : (typeHint ? "typ nämnd" : "saknas")}

Instruktioner:
- Om sortbyte men typ saknas: returnera need.clarify=true med öppen fråga (inga options).
- Om typ finns: ge lugna, numrerade steg enligt manualen. Var utförlig och lista korrekta matched_headings från rubrikindex.
- Fyll ALLA fält i JSON-schemat.
`.trim();

    // --- OpenAI ---
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${process.env.OPENAI_API_KEY}`,
      },
      body: JSON.stringify({
        model: "gpt-4o",
        temperature: 0.2,
        max_tokens: 2000,
        messages: [
          { role: "system", content: system },
          { role: "user", content: user }
        ],
      }),
    });

    const data = await response.json();
    if (!response.ok) {
      console.error("OpenAI chat error:", data);
      return res.status(500).json({ error: "Chat API error", details: data });
    }

    let content = data.choices?.[0]?.message?.content || "";
    let out;
    try { out = JSON.parse(content); }
    catch {
      out = {
        spoken: content || "Jag saknar tydlig information för att guida dig.",
        need: { clarify: false },
        cards: {
          summary: content || "—",
          steps: [],
          explanation: "",
          pitfalls: [],
          simple: content || "",
          pro: content || "",
          follow_up: "",
          coverage: 0,
          matched_headings: []
        },
        follow_up: ""
      };
    }

    // ---- PHASE 1: Klarifiering → returnera direkt (ingen gate) ----
    if (sortIntent && !typeHint && !pair.hasPair) {
      if (!out?.need?.clarify) {
        out.need = { clarify: true, question: "Vilken produkt går du från – och till? (ex: läsk till läsk)", options: [] };
        out.spoken = "För att guida rätt behöver jag veta vilken produkt du byter från – och till. Säg det så tar vi det steg för steg.";
      } else {
        out.spoken = out.need.question || "Vilken produkt går du från – och till?";
        if (Array.isArray(out.need.options) && out.need.options.length) out.need.options = []; // inga påhittade val
      }
      return res.status(200).json({ reply: out });
    }

    // ---- PHASE 2: Typ finns → coachning, mjuk gate ----
    const steps = Array.isArray(out?.cards?.steps) ? out.cards.steps : [];
    let heads = Array.isArray(out?.cards?.matched_headings) ? out.cards.matched_headings : [];
    let cov = Number(out?.cards?.coverage ?? out?.coverage ?? 0) || 0;

    // Om modellen missade rubriker: fyll på med våra relevanta
    if (heads.length === 0 && relHeadings.length > 0) {
      heads = relHeadings.slice(0, 6);
      if (out.cards) out.cards.matched_headings = heads;
    }

    // Bump vid sortbyte + substans
    if (sortIntent) {
      if (steps.length >= 6)  cov = Math.max(cov, 0.58);
      if (steps.length >= 10) cov = Math.max(cov, 0.65);
      if (heads.length >= 1)  cov = Math.max(cov, 0.6);
    }

    // HÅRT STOPP: bara om det verkligen saknas
    if (cov < 0.15 && heads.length === 0 && steps.length < 4) {
      out.cards = out.cards || {};
      out.cards.summary = "Den informationen finns inte tillräckligt tydligt i manualen.";
      out.cards.steps = [];
      out.cards.explanation = "Följ generella säkra rutiner eller kontakta ansvarig. Vi bör uppdatera manualen med detta.";
      out.cards.pitfalls = [];
      out.cards.simple = out.cards.summary;
      out.cards.pro = out.cards.summary;
      out.cards.follow_up = "Vill du att jag noterar att manualen behöver uppdateras för just detta?";
      out.cards.coverage = cov;
      out.cards.matched_headings = heads;
      out.spoken = "Jag saknar täckning i manualen för att guida säkert. Vill du att vi tar generella säkra steg eller uppdaterar manualen?";
      out.need = out.need || { clarify: false };
      out.follow_up = out.cards.follow_up;
      return res.status(200).json({ reply: out });
    }

    // Mjuk varning: leverera steg, men be om verifiering (om <0.6)
    if (cov < 0.6) {
      if (out.cards) {
        out.cards.coverage = cov;
        out.cards.matched_headings = heads;
        out.cards.follow_up = out.cards.follow_up || "Vill du att jag bryter ner nästa del?";
      }
      const warn = "Jag guidar enligt relevanta avsnitt — dubbelkolla gärna mot rubrikerna jag visar.";
      out.spoken = out.spoken ? `${out.spoken} ${warn}` : warn;
      out.follow_up = out.follow_up || "Säg till när du vill ha nästa steg.";
      return res.status(200).json({ reply: out });
    }

    // OK täckning
    if (out.cards) {
      out.cards.coverage = cov;
      out.cards.matched_headings = heads;
    }
    return res.status(200).json({ reply: out });
  } catch (err) {
    console.error("chat.js internal error:", err);
    return res.status(500).json({ error: "Serverfel i chat.js", details: err.message || String(err) });
  }
}
