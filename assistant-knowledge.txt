// Minimal, fri men säker: bygg svaret från manualen, fråga om oklarheter,
// och stoppa bara om det verkligen saknas underlag.

const KNOWLEDGE_URL = "https://raw.githubusercontent.com/172172/Coach-Assistant/main/assistant-knowledge.txt";
const CACHE_MS = 5 * 60 * 1000;

let knowledgeCache = { text: null, fetchedAt: 0 };
async function getKnowledge() {
  const now = Date.now();
  if (knowledgeCache.text && now - knowledgeCache.fetchedAt < CACHE_MS) return knowledgeCache.text;
  const res = await fetch(KNOWLEDGE_URL, { cache: "no-store" });
  if (!res.ok) throw new Error(`Misslyckades hämta kunskap: ${res.status}`);
  const text = await res.text();
  knowledgeCache = { text, fetchedAt: now };
  return text;
}

// små helpers för kontext
const norm = (s="") => s.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g,"").replace(/ö/g,"o").replace(/ä/g,"a").replace(/å/g,"a").trim();
const isSortQ = (s="") => /(sort\s*byte|sortbyte|byta sort|byte i tappen|sortbyten?)/.test(norm(s));
const hasType  = (s="") => /(ol|lager|ale|stout|ipa|lask|soda|vatten|juice|cider|energi|sirap|syrup|smak|kolsyrad|still)/.test(norm(s));
const pairFrom = (s="") => {
  const m = norm(s).match(/(?:fran\s+)?([a-z0-9\-]+)\s*(?:->|→|till)\s*([a-z0-9\-]+)/i);
  return m ? { has:true, from:m[1], to:m[2] } : { has:false };
};

export default async function handler(req, res) {
  try {
    if (req.method !== "POST") return res.status(405).json({ error: "Only POST allowed" });

    const { message = "", prev = null } = req.body || {};
    const knowledge = await getKnowledge();

    const system = `
Du är "Coach Assistant" – varm, lugn, pedagogisk, pratar som en kollega.
Du får gärna vara fri i språket, men all teknik ska bygga på "Kunskap" nedan.

Regler:
- Om underlaget är oklart: ställ EN tydlig följdfråga för att få rätt kontext.
- Om underlaget är tillräckligt: ge tydliga, NUMRERADE steg (gärna 8–20 om manualen räcker), plus kort sammanfattning.
- Säg aldrig påhittade siffror. Om manualen saknar värden: håll det generellt ("enligt manualens gränsvärden").
- Returnera EXAKT JSON:
{
  "spoken": string,                            // naturligt talat svar
  "need": { "clarify": boolean, "question"?: string }, // sätt clarify=true om du behöver ett förtydligande
  "cards": {
    "summary": string,
    "steps": string[],                         // numrerade steg i textform
    "explanation": string,
    "pitfalls": string[],
    "simple": string,
    "pro": string,
    "follow_up": string,
    "coverage": number,                        // 0..1 - DIN realistiska skattning
    "matched_headings": string[]               // exakta rubriker du använt ur Kunskap
  },
  "follow_up": string
}

Vägledning för coverage (inte för försiktig):
- ~0.75+: flera direkt relevanta rubriker, steg direkt därifrån.
- ~0.6–0.75: delvis stöd; komplettera med säkra generella formuleringar.
- ~0.4–0.6: viss relevans; leverera steg men påminn att verifiera mot rubrikerna.
- <0.2: för svagt → be om mer info eller säg att manualen saknar tydlighet.
`.trim();

    const user = `
Kunskap:
"""
${knowledge}
"""

Användarens inmatning:
"${message}"

Tidigare tur (för kontext):
${prev ? JSON.stringify(prev) : "null"}

Instruktion:
- Om frågan är för vag för att ge korrekta steg: returnera need.clarify=true med en kort ÖPPEN fråga.
- Annars: ge fulla, lugna, numrerade steg enligt manualen. Var utförlig om sortbyte/tapp.
- Fyll ALLA fält i JSON-schemat. Ingen text utanför JSON.
`.trim();

    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${process.env.OPENAI_API_KEY}`,
      },
      body: JSON.stringify({
        model: "gpt-4o",
        temperature: 0.25,
        max_tokens: 2000,
        messages: [
          { role: "system", content: system },
          { role: "user", content: user }
        ],
      }),
    });

    const data = await response.json();
    if (!response.ok) {
      console.error("OpenAI chat error:", data);
      return res.status(500).json({ error: "Chat API error", details: data });
    }

    let content = data.choices?.[0]?.message?.content || "";
    let out;
    try { out = JSON.parse(content); }
    catch {
      out = {
        spoken: "Jag behöver lite mer info för att guida rätt. Vad exakt vill du göra?",
        need: { clarify: true, question: "Vad exakt vill du göra?" },
        cards: {
          summary: "Behöver mer kontext.",
          steps: [],
          explanation: "",
          pitfalls: [],
          simple: "",
          pro: "",
          follow_up: "",
          coverage: 0,
          matched_headings: []
        },
        follow_up: ""
      };
    }

    // Enkel, snäll gate: stoppa bara om det verkligen saknas underlag
    const cov   = Number(out?.cards?.coverage ?? 0);
    const heads = Array.isArray(out?.cards?.matched_headings) ? out.cards.matched_headings : [];
    const steps = Array.isArray(out?.cards?.steps) ? out.cards.steps : [];

    // Om modellen ber om förtydligande → returnera direkt (ingen gate)
    if (out?.need?.clarify) {
      out.cards.coverage = cov || 0;
      return res.status(200).json({ reply: out });
    }

    // HÅRT STOPP endast vid riktigt tunt underlag
    if ((cov < 0.2 && heads.length === 0) && steps.length < 4) {
      out.spoken = "Manualen är för tunn för att jag ska kunna guida säkert. Vill du att jag tar generella säkra steg, eller ska vi uppdatera manualen?";
      out.cards.summary = "Otillräckligt underlag i manualen för detaljerade steg.";
      out.cards.steps = [];
      out.cards.explanation = "Följ generella säkra rutiner eller kontakta ansvarig. Uppdatera manualen för detta moment.";
      out.cards.pitfalls = [];
      out.cards.simple = out.cards.summary;
      out.cards.pro = out.cards.summary;
      out.cards.follow_up = "Vill du att jag noterar ett behov av uppdatering i manualen?";
      out.cards.coverage = cov || 0;
      return res.status(200).json({ reply: out });
    }

    // I alla andra fall: leverera som modellen vill (fri, men baserad på manualen)
    // Säkerställ att fält finns
    out.cards = out.cards || {
      summary: "", steps: [], explanation:"", pitfalls:[], simple:"", pro:"", follow_up:"", coverage: cov || 0, matched_headings: heads
    };
    return res.status(200).json({ reply: out });
  } catch (err) {
    console.error("chat.js internal error:", err);
    return res.status(500).json({ error: "Serverfel i chat.js", details: err.message || String(err) });
  }
}
