<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Coach Assistant</title>
  <link rel="icon" href="data:,">
  <style>
    :root { --bg:#0b0b0f; --fg:#fff; --acc:#00aaff; --mut:#b9c0c7; }
    body { font-family: system-ui, sans-serif; padding: 2rem; background: var(--bg); color: var(--fg); }
    .row { display:flex; gap:1rem; align-items:center; flex-wrap:wrap; }
    button { padding:.9rem 1.2rem; font-size:1rem; cursor:pointer; border:none; border-radius:12px; background:var(--acc); color:#fff; }
    #output { margin-top: 1rem; font-size:1.05rem; }
    .status { font-size:.95rem; color:#cfd6dd }
    .pill { background:#12141a; border:1px solid #232733; padding:.75rem .9rem; border-radius:12px; margin-top:.6rem }
    .dot { width:10px; height:10px; border-radius:50%; display:inline-block; margin-right:.5rem; vertical-align:middle }
    .listen { background:#22c55e } .think{ background:#facc15 } .speak{ background:#60a5fa } .idle{ background:#6b7280 }
    #vizWrap { margin-top:1rem; background:#0f1220; border:1px solid #20263a; border-radius:16px; padding:.5rem; }
    canvas { width:100%; height:140px; display:block; border-radius:12px; background:linear-gradient(180deg,#0f1220,#0b0c14); }
    .src { font-size:.85rem; color:#9aa3ad; margin-top:.3rem }
  </style>
</head>
<body>
  <h1>Coach Assistant</h1>
  <p class="status"><span class="dot idle"></span><span id="recStatus">Redo – tryck start. Presentera dig: “Hej, det är Kevin”. Prata normalt för att avbryta svar.</span></p>

  <div class="row">
    <button id="startBtn">▶️ Starta röstloop</button>
    <button id="stopBtn" style="background:#ef4444;display:none">⏹️ Stoppa</button>
  </div>

  <div id="vizWrap"><canvas id="viz" width="800" height="140"></canvas></div>

  <div id="output"></div>

  <script>
    const startBtn = document.getElementById('startBtn');
    const stopBtn  = document.getElementById('stopBtn');
    const output   = document.getElementById('output');
    const recStatus= document.getElementById('recStatus');
    const canvas   = document.getElementById('viz');
    const ctx      = canvas.getContext('2d');

    // ---------- STATE ----------
    let state = 'IDLE', running = false;

    // Profil via presentation (behålls, men servern kör Jarvis-stil)
    let profileName = localStorage.getItem('coach_profile') || null;

    // Mic / analyser
    let micStream = null, mediaRecorder = null, chunks = [];
    let audioCtxVAD = null, analyser = null, micArr = null;

    // TTS
    let ttsCtx = null, ttsSource = null, ttsAnalyser = null, ttsGainNode = null;
    const TTS_BASE_GAIN = 0.85;
    const TTS_DUCK_GAIN = 0.22;

    // Enkelt “konversationsminne” för uppföljningsfrågor
    let lastQ = null;
    let lastA = null;

    // Barge-in/VAD grund
    const SILENCE_THRESHOLD = 12;   // baseline (används endast initialt)
    const SILENCE_HOLD_MS   = 900;
    const MAX_RECORD_MS     = 12000;

    let speakBaseline = 0;          // adaptiv baseline för TTS-läckage
    const BARGE_MARGIN    = 4;      // lite känsligare
    const BARGE_MIN_LEVEL = 16;
    const BARGE_HOLD_MS   = 130;    // snabbare avbrott
    let bargeHold = 0;

    // --- Dynamisk MIME (Safari iOS behöver mp4/m4a) ---
    const REC_MIME =
      MediaRecorder.isTypeSupported('audio/webm;codecs=opus') ? 'audio/webm;codecs=opus' :
      MediaRecorder.isTypeSupported('audio/webm') ? 'audio/webm' :
      MediaRecorder.isTypeSupported('audio/mp4') ? 'audio/mp4' : '';
    const REC_EXT = REC_MIME.includes('mp4') ? 'm4a' : 'webm';

    // Barge cooldown (hindrar studs mellan tala/lyssna)
    let bargeCooldownMs = 0;
    const BARGE_COOLDOWN_SET = 600; // ms spärr efter barge-in

    // Adaptiv tystnadströskel
    let BASE_NOISE = 0;
    let DYNAMIC_SILENCE = SILENCE_THRESHOLD;

    // Minsta krav för att räkna ett klipp som "tal"
    const MIN_SPEECH_MS = 400;     // du måste prata minst 0.4s totalt
    const MIN_BLOB_BYTES = 20000;  // släng väldigt små klipp (tystnad)

    // Vanliga hallisar vid tystnad → ignorera om de råkar dyka upp
    const HALLUCINATION_PATTERNS = /(patreon|prenumerera|videon|undertexter|amara\.org)/i;

    function setStatus(mode, text) {
      const dotClass = mode === 'LISTENING' ? 'listen' : mode === 'THINKING' ? 'think' : mode === 'SPEAKING' ? 'speak' : 'idle';
      recStatus.previousElementSibling.className = `dot ${dotClass}`;
      recStatus.textContent = text + (profileName ? `  • Profil: ${profileName}` : '');
    }

    // ---------- Utils ----------
    function rmsLevel(uint8PCM) {
      let sum=0; for (let i=0;i<uint8PCM.length;i++){ const v=uint8PCM[i]-128; sum+=v*v; }
      const rms=Math.sqrt(sum/uint8PCM.length);
      return Math.min(255, Math.max(0, Math.round(rms*6)));
    }
    function trySetProfileFrom(text) {
      const t=(text||'').toLowerCase();
      const m=t.match(/\b(det är|de e|det e|jag heter|mitt namn är)\s+([a-zåäö\- ]{2,})/i);
      if (m){ const name=m[2].trim().split(/\s+/)[0]; if(name){ profileName=name.charAt(0).toUpperCase()+name.slice(1); localStorage.setItem('coach_profile',profileName); output.insertAdjacentHTML('beforeend',`<div class="pill">Profil aktiverad: <strong>${profileName}</strong></div>`); return true; } }
      if (/\b(glöm min profil|ta bort profil)\b/i.test(t)){ profileName=null; localStorage.removeItem('coach_profile'); output.insertAdjacentHTML('beforeend',`<div class="pill">Profil rensad – neutral stil.</div>`); return true; }
      return false;
    }

    async function calibrateNoiseOnce() {
      if (!analyser || !micArr) return;
      let acc = 0, n = 0; 
      const t0 = performance.now();
      while (performance.now() - t0 < 220) {
        analyser.getByteTimeDomainData(micArr);
        acc += rmsLevel(micArr); n++;
        await new Promise(r => setTimeout(r, 30));
      }
      BASE_NOISE = Math.round(acc / Math.max(1, n));
      DYNAMIC_SILENCE = Math.max(8, BASE_NOISE + 3);
    }

    // ---------- Visualizer + BARGe-IN monitor (EN loop) ----------
    let rafId = null, lastTs = 0, phase = 0;
    function loop(ts){
      const dt = Math.min(200, ts - (lastTs||ts)); lastTs = ts;

      if (bargeCooldownMs > 0) { bargeCooldownMs -= dt; }

      // nivåer
      let micLevel = 0, ttsLevel = 0;
      if (analyser && micArr){ analyser.getByteTimeDomainData(micArr); micLevel = rmsLevel(micArr); }
      if (ttsAnalyser){ const arr = new Uint8Array(ttsAnalyser.fftSize); ttsAnalyser.getByteTimeDomainData(arr); ttsLevel = rmsLevel(arr); }

      // ---- BARGe-IN + DUCKING ----
      if (running && state === 'SPEAKING' && analyser){
        // uppdatera baseline (EMA) – hur mycket TTS “läcker” in i micken
        speakBaseline = speakBaseline ? (0.92*speakBaseline + 0.08*micLevel) : micLevel;
        const threshold = Math.max(BARGE_MIN_LEVEL, speakBaseline + BARGE_MARGIN);

        if (micLevel > threshold) {
          // sänk TTS-volym direkt så du bryter igenom
          if (ttsGainNode && ttsCtx) {
            try { ttsGainNode.gain.setTargetAtTime(TTS_DUCK_GAIN, ttsCtx.currentTime, 0.015); } catch {}
          }

          if (bargeCooldownMs <= 0) {
            bargeHold += dt;
            if (bargeHold >= BARGE_HOLD_MS){
              bargeCooldownMs = BARGE_COOLDOWN_SET;
              stopTTS();
              startListening();
              bargeHold = 0;
            }
          }
        } else {
          bargeHold = 0;
          // släpp upp TTS-volym när du inte pratar
          if (ttsGainNode && ttsCtx) {
            try { ttsGainNode.gain.setTargetAtTime(TTS_BASE_GAIN, ttsCtx.currentTime, 0.05); } catch {}
          }
        }
      }

      drawViz(micLevel, ttsLevel);
      rafId = requestAnimationFrame(loop);
    }
    function drawViz(micLevel, ttsLevel){
      const w=canvas.width, h=canvas.height;
      ctx.clearRect(0,0,w,h);
      const g=ctx.createLinearGradient(0,0,0,h);
      g.addColorStop(0,'#0e1222'); g.addColorStop(1,'#0a0d18'); ctx.fillStyle=g; ctx.fillRect(0,0,w,h);
      const base = state==='SPEAKING'? ttsLevel : micLevel;
      const amp  = Math.min(1, base/50); phase += 0.015 + amp*0.02;
      const cx=w*0.5, cy=h*0.56, radius=26+amp*18;
      ctx.beginPath();
      for(let i=0;i<64;i++){
        const ang=(i/64)*Math.PI*2;
        const r=radius + Math.sin(ang*3 + phase*3)*4*amp + Math.cos(ang*2.2 + phase*2)*3*amp;
        const x=cx+Math.cos(ang)*r, y=cy+Math.sin(ang)*r;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath();
      const blobGrad=ctx.createRadialGradient(cx,cy,radius*0.3,cx,cy,radius*1.1);
      blobGrad.addColorStop(0, state==='SPEAKING'?'#63b3ff':'#3fe08a'); blobGrad.addColorStop(1,'#0b1022');
      ctx.fillStyle=blobGrad; ctx.fill();
      ctx.beginPath();
      const mid=h*0.78, A=10+amp*22, freq=0.018+amp*0.01;
      for(let x=0;x<w;x++){ const y=mid + Math.sin(x*freq + phase*4)*A*Math.cos(x*0.003 + phase); if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
      ctx.strokeStyle = state==='SPEAKING'?'rgba(99,179,255,0.9)':'rgba(63,224,138,0.9)';
      ctx.lineWidth=2; ctx.stroke();
    }

    // ---------- TTS ----------
    function stopTTS(){
      try{ ttsSource && ttsSource.stop(); }catch{}
      ttsSource=null; ttsAnalyser=null;
      if(ttsCtx){ try{ ttsCtx.close(); }catch{} }
      ttsCtx=null; ttsGainNode=null;
    }
    async function speak(text){
      stopTTS();
      state='SPEAKING'; setStatus(state,'Svarar… (prata för att avbryta)');
      try{
        const res = await fetch('/api/tts',{ method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ text }) });
        if(!res.ok) throw new Error('Fel vid TTS-svar');
        const blob=await res.blob(); const arrayBuffer=await blob.arrayBuffer();

        ttsCtx = new (window.AudioContext||window.webkitAudioContext)();
        ttsGainNode = ttsCtx.createGain();
        ttsGainNode.gain.value = TTS_BASE_GAIN;

        ttsSource = ttsCtx.createBufferSource();
        const audioBuffer = await ttsCtx.decodeAudioData(arrayBuffer);
        ttsSource.buffer = audioBuffer;

        ttsAnalyser = ttsCtx.createAnalyser(); ttsAnalyser.fftSize = 1024;

        ttsSource.connect(ttsGainNode).connect(ttsAnalyser).connect(ttsCtx.destination);
        ttsSource.onended = ()=>{ ttsGainNode=null; if(running) startListening(); };
        ttsSource.start(0);

        speakBaseline = 0; bargeHold = 0;
      }catch(err){
        console.error('TTS-fel:',err);
        output.insertAdjacentHTML('beforeend',"<div class='pill'>Kunde inte spela upp ljud.</div>");
        if(running) startListening();
      }
    }

    // ---------- CHAT ----------
    async function askAssistant(text){
      state='THINKING'; setStatus(state,'Bearbetar…');
      output.insertAdjacentHTML('beforeend', `<div class="pill"><strong>Du sa:</strong> ${text} ${profileName?`(profil: ${profileName})`:''}</div>`);
      try{
        const res = await fetch('/api/chat',{
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ message:text, profile: profileName||null, prev: { question: lastQ, assistant: lastA } })
        });
        const data=await res.json(); if(!res.ok) throw new Error(data?.error || 'Chat-fel');

        let r=data.reply; if(typeof r==='string'){ try{ r=JSON.parse(r); }catch{} }
        let toSpeak=''; let srcNote='';

        if(r && typeof r==='object'){
          toSpeak = r.summary || '';
          if(Array.isArray(r.steps)&&r.steps.length){ toSpeak += (toSpeak?' ':'') + 'Steg: ' + r.steps.slice(0,4).join(', ') + '.'; }
          if(r.explanation) toSpeak += ' ' + r.explanation;

          if(Array.isArray(r.matched_headings)&&r.matched_headings.length){ srcNote = `Hämtat från: ${r.matched_headings.join(', ')}`; }
          const html = `
            <div class="pill">
              <div><strong>Sammanfattning:</strong> ${r.summary||'—'}</div>
              ${Array.isArray(r.steps)&&r.steps.length?`<div><strong>Steg:</strong><br>- ${r.steps.join('<br>- ')}</div>`:''}
              ${r.explanation?`<div><strong>Förklaring:</strong> ${r.explanation}</div>`:''}
              ${Array.isArray(r.pitfalls)&&r.pitfalls.length?`<div><strong>Fallgropar:</strong><br>- ${r.pitfalls.join('<br>- ')}</div>`:''}
              ${r.follow_up?`<div><em>${r.follow_up}</em></div>`:''}
              ${srcNote?`<div class="src">${srcNote}</div>`:''}
            </div>`;
          output.insertAdjacentHTML('beforeend', html);

          // spara kontext för nästa uppföljning
          lastQ = text;
          lastA = r;
        } else {
          const fallback = typeof data.reply === 'string' ? data.reply : 'Jag kunde inte formulera ett svar.';
          output.insertAdjacentHTML('beforeend', `<div class="pill"><strong>Svar:</strong><br>${fallback}</div>`);
          toSpeak = fallback;
          lastQ = text; lastA = null;
        }
        await speak(toSpeak || 'Oklart svar.');
      }catch(err){
        console.error('Chat-fel:',err);
        output.insertAdjacentHTML('beforeend', `<div class="pill">Kunde inte få svar från AI.</div>`);
        if(running) startListening();
      }
    }

    // ---------- Whisper ----------
    async function transcribe(blob){
      const fd = new FormData();
      const typedBlob = new Blob([blob], { type: REC_MIME || 'audio/webm' });
      fd.append('audio', typedBlob, `audio.${REC_EXT}`);
      fd.append('mime', REC_MIME || 'audio/webm');

      const res=await fetch('/api/whisper',{ method:'POST', body: fd });
      const data=await res.json(); if(!res.ok) throw new Error(data?.error || 'Transkriberingsfel');
      return (data.text||'').trim();
    }

    // ---------- LISTEN ----------
    async function startListening(){
      if(!running) return;
      stopTTS();
      state='LISTENING'; setStatus(state,'Lyssnar… (bli tyst för att skicka)');

      chunks=[]; const startedAt=performance.now();
      let silentMs=0, talkMs=0, everAbove=false;

      await calibrateNoiseOnce();

      const speechThreshold = DYNAMIC_SILENCE + 2;

      mediaRecorder = REC_MIME ? new MediaRecorder(micStream, { mimeType: REC_MIME, audioBitsPerSecond: 128000 })
                               : new MediaRecorder(micStream);

      mediaRecorder.ondataavailable = (e)=>{ if(e.data.size>0) chunks.push(e.data); };
      mediaRecorder.onstop = async ()=>{
        const blob=new Blob(chunks,{type: REC_MIME || 'audio/webm'}); if(!running) return;

        // *** Gating mot tystnad/hallucination ***
        if (!everAbove || talkMs < MIN_SPEECH_MS || blob.size < MIN_BLOB_BYTES) {
          if(running) startListening();
          return;
        }

        try{
          const text = await transcribe(blob);

          // ignorera typiska "YouTube-eftertexter"-hallisar
          if (!text || HALLUCINATION_PATTERNS.test(text)) {
            if(running) startListening();
            return;
          }

          if(!trySetProfileFrom(text)){
            if(text) await askAssistant(text);
            else { output.insertAdjacentHTML('beforeend',"<div class='pill'>Hörde inget tydligt. Prova igen.</div>"); if(running) startListening(); }
          } else { if(running) startListening(); }
        }catch(err){
          console.error('Whisper-fel:',err);
          output.insertAdjacentHTML('beforeend',"<div class='pill'>Kunde inte transkribera ljudet.</div>");
          if(running) startListening();
        }
      };
      mediaRecorder.start();

      const vadTimer=setInterval(()=>{
        analyser.getByteTimeDomainData(micArr);
        const lvl = rmsLevel(micArr);

        if (lvl >= speechThreshold) {
          talkMs += 100;             // räknas som tal
          silentMs = 0;
          everAbove = true;
        } else {
          silentMs += 100;
        }

        const elapsed = performance.now()-startedAt;
        if (silentMs >= SILENCE_HOLD_MS || elapsed > MAX_RECORD_MS){
          clearInterval(vadTimer);
          try{ mediaRecorder.state!=='inactive' && mediaRecorder.stop(); }catch{}
        }
      },100);
    }

    // ---------- START/STOP ----------
    async function startLoop(){
      if(running) return; running=true;
      startBtn.style.display='none'; stopBtn.style.display='inline-block';

      try{
        micStream = await navigator.mediaDevices.getUserMedia({
          audio: { echoCancellation:true, noiseSuppression:true, autoGainControl:false }
        });
      }catch(e){
        output.insertAdjacentHTML('beforeend', "<div class='pill'>Mikrofon kunde inte startas (behörighet?).</div>");
        running=false; startBtn.style.display='inline-block'; stopBtn.style.display='none'; return;
      }

      audioCtxVAD = new (window.AudioContext||window.webkitAudioContext)();
      const src = audioCtxVAD.createMediaStreamSource(micStream);
      analyser = audioCtxVAD.createAnalyser(); analyser.fftSize = 2048;
      micArr = new Uint8Array(analyser.fftSize); src.connect(analyser);

      if(!rafId) rafId = requestAnimationFrame(loop);
      startListening();
    }

    function stopLoop(){
      running=false; state='IDLE'; setStatus(state,'Stoppad');
      startBtn.style.display='inline-block'; stopBtn.style.display='none';

      if(rafId){ cancelAnimationFrame(rafId); rafId=null; lastTs=0; }
      stopTTS();
      try{ mediaRecorder && mediaRecorder.state!=='inactive' && mediaRecorder.stop(); }catch{}
      try{ analyser && analyser.disconnect(); }catch{}
      try{ audioCtxVAD && audioCtxVAD.close(); }catch{}
      analyser=null; audioCtxVAD=null; micArr=null;
      if(micStream){ micStream.getTracks().forEach(t=>t.stop()); micStream=null; }
    }

    // Snabb manuell avbryt (klick/space) om du vill
    document.addEventListener('click', ()=>{ if (running && state==='SPEAKING'){ bargeCooldownMs=BARGE_COOLDOWN_SET; stopTTS(); startListening(); }});
    window.addEventListener('keydown',(e)=>{ if(e.key===' ' && state==='SPEAKING'){ e.preventDefault(); bargeCooldownMs=BARGE_COOLDOWN_SET; stopTTS(); startListening(); }});

    startBtn.addEventListener('click', startLoop);
    stopBtn.addEventListener('click', stopLoop);
    window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') stopLoop(); });
  </script>
</body>
</html>
