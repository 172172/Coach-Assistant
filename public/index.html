<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Coach Assistant ‚Äì Linje 65 (Realtime)</title>
  <style>
    :root {
      --bg: #0b0f14;
      --panel: #121821;
      --text: #e6edf3;
      --muted: #9fb0c3;
      --accent: #5eead4;
      --danger: #f87171;
      --ok: #86efac;
      --pill: #182232;
    }
    html, body { height: 100%; }
    body {
      margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Noto Sans", "Helvetica Neue", Arial;
      background: radial-gradient(1200px 600px at 20% 0%, #0e1621, #0b0f14 75%);
      color: var(--text);
    }
    .wrap { max-width: 980px; margin: 0 auto; padding: 24px; }
    header { display:flex; align-items:center; justify-content:space-between; gap:16px; margin-bottom: 16px; }
    header .title { font-size: 20px; font-weight: 700; letter-spacing: .3px; }
    .controls { display:flex; flex-wrap: wrap; gap:8px; align-items:center; }
    button { appearance:none; border: none; padding: 10px 14px; border-radius: 12px; cursor:pointer; font-weight: 600; }
    .primary { background: var(--accent); color:#0a0f14; }
    .ghost { background: #0d1520; color: var(--text); border: 1px solid #233146; }
    .danger { background: var(--danger); color: #111; }
    .muted { color: var(--muted); font-size: 13px; }
    .row { display:flex; gap:10px; align-items:center; }
    input[type="text"], input[type="search"] { background:#0d1622; color:var(--text); border:1px solid #243244; border-radius:10px; padding:10px 12px; }
    .pill { background: var(--pill); color: var(--text); padding: 8px 12px; border-radius: 999px; display:inline-block; margin: 6px 6px 0 0; font-size: 12px; border:1px solid #26364a; }
    .panel { background: var(--panel); border: 1px solid #233146; border-radius: 16px; padding: 14px; }
    #output { display:flex; flex-direction: column; gap: 10px; margin-top: 14px; }
    .bubble { background:#0f1722; border:1px solid #213145; border-radius:16px; padding:12px 14px; white-space: pre-wrap; line-height: 1.45; }
    .bubble.user { background:#0f1a27; border-color:#24415a; }
    .bubble.assistant { background:#0f1823; border-color:#2c3f57; }
    .bubble.error { background:#1b0f12; border-color:#4a1f2a; }
    .tag { font-size: 11px; opacity:.8; }
    .status { margin-left: 8px; }
    .vis { height: 10px; background: #0e1420; border-radius: 9999px; overflow: hidden; border:1px solid #213145; }
    .vis > b { display:block; height:100%; width: 6%; background: linear-gradient(90deg,#85f3d5,#4dd4ff); transition: width .08s linear; }
    footer { margin-top: 24px; color: var(--muted); font-size: 12px; }
    .src { font-size:12px; margin-top:6px; color:#bfd7ff; opacity:.9; }
    .flex { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">ü¶æ Coach Assistant ‚Äì Linje 65 (Realtime)</div>
      <div class="controls">
        <div class="row">
          <label class="muted" for="operatorId">Operat√∂r:</label>
          <input id="operatorId" type="text" placeholder="t.ex. kevin" style="width:140px" />
          <button class="ghost" id="saveIdBtn">Spara</button>
        </div>
        <button class="primary" id="rtBtn">Anslut Realtime</button>
        <button class="ghost" id="rtHangup" style="display:none">L√§gg p√•</button>
      </div>
    </header>

    <div class="panel">
      <div class="flex">
        <div id="rtStatus" class="pill">Inte ansluten</div>
        <div id="memStatus" class="pill">Minne: ‚Äî</div>
        <div class="vis" style="flex:1 1 220px; min-width:220px"><b id="micBar"></b></div>
      </div>

      <div class="row" style="margin-top:10px">
        <input id="quickText" type="search" placeholder="Skicka text till assistenten (enter)" style="flex:1" />
        <button class="ghost" id="sendTextBtn">Skicka</button>
      </div>

      <!-- Manuell fels√∂kning av RAG utan Realtime -->
      <div class="row" style="margin-top:10px">
        <input id="manualQuery" type="search" placeholder="Testa manual-s√∂k (t.ex. 'sortbyte i tappen')" style="flex:1" />
        <button class="ghost" id="manualBtn">Testa manual</button>
      </div>

      <div id="output"></div>
    </div>

    <footer>
      Realtime-r√∂st med WebRTC. Manual/RAG via Supabase. Logg + minne i Supabase (conversations/messages/summary).<br>
      <span class="muted">Tips: s√§g "Spara detta" s√• kan assistenten l√§gga i l√•ngtidsminne via save_memory.</span>
    </footer>
  </div>

  <script>
    // ========= UI helpers =========
    const $ = sel => document.querySelector(sel);
    const $$ = sel => Array.from(document.querySelectorAll(sel));

    async function fetchJSON(url, opts) {
      const r = await fetch(url, opts);
      const t = await r.text();
      let j; try { j = JSON.parse(t); } catch { throw new Error(`${r.status} ${r.statusText}: ${t.slice(0,200)}`); }
      if (!r.ok || j?.ok === false) throw new Error(j?.error || j?.message || `${r.status} ${r.statusText}`);
      return j;
    }

    function pill(text) { const d = document.createElement('div'); d.className = 'pill'; d.textContent = text; return d; }
    function bubble(text, role='assistant') { const d = document.createElement('div'); d.className = 'bubble ' + role; d.textContent = text; return d; }
    function errorBubble(text) { const d = document.createElement('div'); d.className = 'bubble error'; d.textContent = text; return d; }
    function append(el) { $('#output').appendChild(el); el.scrollIntoView({behavior:'smooth', block:'end'}); }

    // ========= Operator ID =========
    const operatorInput = $('#operatorId');
    operatorInput.value = localStorage.getItem('operator_id') || 'kevin';
    $('#saveIdBtn').onclick = () => {
      localStorage.setItem('operator_id', operatorInput.value.trim() || 'kevin');
      append(pill('Operat√∂r sparad: ' + (localStorage.getItem('operator_id'))));
    };

    // ========= Realtime state =========
    let rt = {
      pc:null, dc:null, mic:null, remoteAudio:null, connected:false,
      conversation_id:null, _msgCount:0,
      _ragBusy:false, _lastQuery:"", _lastToolCallId:null,
      cancelAutos:false,                // stoppa modellens spontana svar n√§r vi k√∂r RAG
      skipCancelForNextCreate:false,    // sl√§pp igenom v√•rt n√§sta response.created
      allowedResponseIds:new Set(),     // responses vi till√•ter (h√∂r till aktiv tool-respons)
      _lastUserText:"",                 // senaste finala transkriptet
      _liveUserBuf:""                   // p√•g√•ende (icke-final) transkript
    };
    const toolCalls = new Map(); // tool_call_id -> { name, argsText, launched?, response_id? }

    const RAG_TIMEOUT_MS = 8000;
    let ragTimer = null;

    // mic visualizer
    let micAnalyser, micData;
    function setupMicViz(stream) {
      try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const src = ctx.createMediaStreamSource(stream);
        micAnalyser = ctx.createAnalyser();
        micAnalyser.fftSize = 512; micAnalyser.smoothingTimeConstant = 0.8;
        src.connect(micAnalyser);
        micData = new Uint8Array(micAnalyser.frequencyBinCount);
        const bar = $('#micBar');
        (function loop(){
          if (!micAnalyser) return; micAnalyser.getByteTimeDomainData(micData);
          let peak = 0; for (let i=0;i<micData.length;i++){ const v = Math.abs(micData[i]-128)/128; if (v>peak) peak=v; }
          bar.style.width = Math.min(98, (peak*100*1.6)+6) + '%';
          requestAnimationFrame(loop);
        })();
      } catch(e) {}
    }

    // ========= Logging (tysta fel) =========
    async function logMsg(role, content, modality='voice', payload=null) {
      if (!rt.conversation_id) return;
      try {
        const res = await fetch('/api/memory-log', {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ conversation_id: rt.conversation_id, role, content, modality, payload })
        });
        if (!res.ok) console.warn('LOGGNING FEL:', await res.text());
        rt._msgCount = (rt._msgCount || 0) + 1;
        if (rt._msgCount % 8 === 0) {
          fetch('/api/memory-summarize', {
            method: 'POST', headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ conversation_id: rt.conversation_id })
          }).then(()=> $('#memStatus').textContent = 'Minne: uppdaterat').catch(()=>{});
        }
      } catch(e) { console.warn('LOGGNING FEL:', e?.message || e); }
    }

    // ========= Connect Realtime =========
    $('#rtBtn').addEventListener('click', connectRealtime);
    $('#rtHangup').addEventListener('click', hangupRealtime);

    async function connectRealtime() {
      const status = t => $('#rtStatus').textContent = t;
      try {
        rt.mic = await navigator.mediaDevices.getUserMedia({ audio: true });
        setupMicViz(rt.mic);

        // Init memory
        const memInit = await fetchJSON('/api/memory-init', {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ userId: localStorage.getItem('operator_id') || 'kevin' })
        });
        rt.conversation_id = memInit.conversation_id;
        $('#memStatus').textContent = 'Minne: laddat';

        // RTCPeerConnection
        rt.pc = new RTCPeerConnection();
        rt.mic.getTracks().forEach(t => rt.pc.addTrack(t, rt.mic));
        rt.remoteAudio = new Audio(); rt.remoteAudio.autoplay = true; rt.remoteAudio.playsInline = true; rt.remoteAudio.muted = false;
        rt.pc.ontrack = (e) => { rt.remoteAudio.srcObject = e.streams[0]; };

        // Data channel
        rt.dc = rt.pc.createDataChannel('oai-events');
        rt.dc.onopen = () => {
          const sessUpdate = {
            type: 'session.update',
            session: {
              voice: 'verse',
              turn_detection: { type: 'server_vad' },
              tool_choice: { type: 'auto' },
              instructions: `
Du √§r Coach Assistant f√∂r Linje 65.
Vid fr√•gor om drift/fels√∂kning/manual ska du ALLTID anv√§nda verktyget "search_manual" innan du svarar.
V√ÑNTA tills du har ett slutligt (final) transkript innan du kallar "search_manual".
N√§r du kallar "search_manual": skicka alltid { query: EXAKT senaste anv√§ndarens transkript }, inte tom str√§ng och inte parafras.
N√§r "search_manual" returnerar "strict_answer": L√ÑS UPP DET ORDAGRANT (max 2 meningar), utan egna till√§gg.
Om "strict_answer" saknas: S√§g att du inte kan verifiera i manualen och be om precisering (delomr√•de, felkod, maskin).
H√§lsning/sm√•prat kan besvaras utan verktyg.
`.trim(),
              tools: [
                {
                  type: 'function',
                  name: 'search_manual',
                  description: `S√∂k i Linje65-manualdatabasen och returnera tr√§ffar med k√§llor.
OUTPUT (JSON string): {
  ok: boolean,
  strict_answer?: string,
  best_sentence?: string,
  numeric?: { value:number, sentence:string } | null,
  fallback?: boolean,
  top_score?: number,
  sources: Array<{ title?:string, idx?:number, score?:number }>
}`,
                  parameters: {
                    type: 'object',
                    properties: {
                      query: { type: 'string', description: 'Anv√§ndarens fr√•ga (senaste transkript).' },
                      k: { type: 'integer', default: 5 },
                      minSim: { type: 'number', default: 0.55 }
                    },
                    required: ['query']
                  }
                },
                {
                  type: 'function',
                  name: 'save_memory',
                  description: 'Spara stabil fakta/inst√§llning i l√•ngtidsminne.',
                  parameters: {
                    type: 'object',
                    properties: { key: { type: 'string' }, value: { type: 'string' } },
                    required: ['key','value']
                  }
                }
              ]
            }
          };
          rt.dc.send(JSON.stringify(sessUpdate));
          append(pill('Realtime ansluten. Prata n√§r som helst.'));
        };

        rt.dc.onmessage = (e) => {
          try { handleRealtimeMessage(JSON.parse(e.data)); } catch { /* ignore non-JSON */ }
        };

        // Offer/answer
        const { token, model } = await fetchJSON('/api/rt-token');
        append(pill('Realtime modell: ' + model));
        const offer = await rt.pc.createOffer();
        await rt.pc.setLocalDescription(offer);
        const sdpAnswer = await fetch(`https://api.openai.com/v1/realtime?model=${encodeURIComponent(model)}`, {
          method: 'POST', headers: { Authorization: `Bearer ${token}`, 'Content-Type': 'application/sdp' }, body: offer.sdp
        }).then(r => r.text());
        await rt.pc.setRemoteDescription({ type: 'answer', sdp: sdpAnswer });

        // UI state
        rt.connected = true;
        $('#rtBtn').style.display = 'none';
        $('#rtHangup').style.display = 'inline-block';
        status('Realtime ansluten');
      } catch (e) {
        console.error(e);
        $('#rtStatus').textContent = `Realtime misslyckades: ${e?.message || e}`;
        append(errorBubble('Fel vid anslutning: ' + (e?.message || e)));
      }
    }

    async function hangupRealtime() {
      try {
        rt.dc?.close();
        rt.pc?.getSenders()?.forEach(s => s.track?.stop());
        rt.pc?.close();
        rt.mic?.getTracks()?.forEach(t => t.stop());
        micAnalyser = null;
      } catch {}
      rt = {
        pc:null, dc:null, mic:null, remoteAudio:null, connected:false,
        conversation_id:rt.conversation_id, _msgCount:rt._msgCount,
        _ragBusy:false, _lastQuery:"", _lastToolCallId:null,
        cancelAutos:false, skipCancelForNextCreate:false, allowedResponseIds:new Set(),
        _lastUserText:"", _liveUserBuf:""
      };
      $('#rtBtn').style.display = 'inline-block';
      $('#rtHangup').style.display = 'none';
      $('#rtStatus').textContent = 'Inte ansluten';
      append(pill('Samtal avslutat.'));
    }

    // ========= Realtime events =========
    function isTranscriptFinalType(t) {
      return t && (
        /^input_audio_buffer\.transcript\.(done|completed)$/.test(t) ||
        /^input_text\.(done|completed)$/.test(t)
      );
    }

    function handleRealtimeMessage(msg) {
      // --- Live transcript buffer (f√∂r tool-call f√∂re final) ---
      try {
        const t = msg?.type || "";
        if (/(input_audio_buffer|input_text)\.transcript\.(started|start)$/.test(t)) {
          rt._liveUserBuf = "";
        }
        if (/(input_audio_buffer|input_text)\.transcript\.delta$/.test(t)) {
          const chunk = msg.delta || msg.text || "";
          if (chunk) rt._liveUserBuf = (rt._liveUserBuf || "") + chunk;
        }
      } catch {}
      // ----------------------------------------------------------

      // function-call args deltas
      if (msg.type === 'response.function_call_arguments.delta') {
        const id = msg.id || msg.tool_call_id || msg.response_id || 'unknown';
        const prev = toolCalls.get(id) || { name: msg.name, argsText: '' };
        prev.argsText += (msg.delta || msg.arguments_delta || '');
        prev.name = prev.name || msg.name;
        if (msg.response_id) prev.response_id = msg.response_id;
        toolCalls.set(id, prev);
        return;
      }

      // response.created ‚Üí stoppa endast n√§r vi ska ers√§tta med RAG
      if (msg.type === 'response.created') {
        const rid = msg.response?.id || msg.response_id;
        if (rid && rt.allowedResponseIds.has(rid)) {
          append(pill('‚úÖ Till√•ter p√•g√•ende tool-respons'));
          return;
        }
        if (rt.cancelAutos) {
          if (rt.skipCancelForNextCreate) {
            rt.skipCancelForNextCreate = false;
            append(pill('‚úÖ Sl√§pper igenom RAG-svar'));
          } else if (rid) {
            rt.dc?.send(JSON.stringify({ type: 'response.cancel', response_id: rid }));
            append(pill('üõë Auto-respons stoppad'));
            return;
          }
        }
        return;
      }

      // tool-call klar ‚Üí k√∂r verktyget och l√§mna OUTPUT till modellen
      if (msg.type === 'response.function_call_arguments.done') {
        const id = msg.id || msg.tool_call_id || 'unknown';
        const tc = toolCalls.get(id) || { name: msg.name, argsText: '' };

        // Spara response_id
        if (msg.response_id) {
          tc.response_id = msg.response_id;
          toolCalls.set(id, tc);
        }

        // Snygg debug
        let args = {};
        try { args = JSON.parse(tc.argsText || '{}'); } catch {}
        if (tc.name) {
          const shown = (args.query || '').slice(0,32);
          append(pill(`TOOL CALL ‚Üí ${tc.name} q="${shown}${(args.query||'').length>32?'‚Ä¶':''}"`));
        }

        // L√∂s query innan vi best√§mmer avbrottslogik
        const q = resolveQueryFromState(args);

        if (tc.name === 'search_manual') {
          // Tom query ‚Üí be modellen v√§nta/precisera, avbryt inte autosvar
          if (!q) {
            rt.cancelAutos = false;
            if (tc.response_id) rt.allowedResponseIds.add(tc.response_id);
            rt.dc?.send(JSON.stringify({
              type: 'response.function_call_output',
              tool_call_id: id,
              output: JSON.stringify({ ok:false, error:'missing_query_wait_final', need_user:true })
            }));
            append(pill('‚è≥ Ignorerar tomt tool-call (v√§ntar p√• final transkript)'));
            return;
          }

          if (rt._ragBusy || tc.launched) return;
          tc.launched = true; toolCalls.set(id, tc);

          rt.cancelAutos = true;
          if (tc.response_id) rt.allowedResponseIds.add(tc.response_id);

          rt._ragBusy = true;
          rt._lastToolCallId = id;
          clearTimeout(ragTimer);
          ragTimer = setTimeout(() => { rt._ragBusy = false; rt.cancelAutos = false; }, RAG_TIMEOUT_MS);

          const patchedArgs = JSON.stringify({ ...args, query: q });
          return runToolSearchManual({ tool_call_id: id, response_id: tc.response_id, argsText: patchedArgs }).finally(()=>{});
        }

        if (tc.name === 'save_memory') {
          if (tc.launched) return;
          tc.launched = true; toolCalls.set(id, tc);
          return runToolSaveMemory(tc);
        }
        return;
      }

      // Fallback: transcript final ‚Üí om modellen inte kallat tool, k√∂r RAG en g√•ng
      if (isTranscriptFinalType(msg.type)) {
        const text = (msg.transcript || msg.text || '').trim();
        if (text) {
          append(bubble(text, 'user'));
          logMsg('user', text, 'voice', msg);
          rt._lastUserText = text;      // spara final
          rt._liveUserBuf = "";         // nollst√§ll live-buffert
          if (text.split(/\s+/).length < 2) return;

          if (!rt._ragBusy && text !== rt._lastQuery) {
            rt._ragBusy = true; rt._lastQuery = text;
            rt.cancelAutos = true;
            clearTimeout(ragTimer);
            ragTimer = setTimeout(() => { rt._ragBusy = false; rt.cancelAutos = false; }, RAG_TIMEOUT_MS);
            runToolSearchManual({ tool_call_id: null, response_id: null, argsText: JSON.stringify({ query: text, k: 5, minSim: 0.55 }) }).finally(()=>{});
          }
        }
        return;
      }

      // Final text ‚Üí visa + sl√§pp l√•s
      if (msg.type === 'response.output_text.done') {
        const text = msg.output_text || msg.text || '';
        if (text?.trim()) {
          append(bubble(text, 'assistant'));
          logMsg('assistant', text, 'voice', msg);
        }
        rt._ragBusy = false;
        rt.cancelAutos = false;
        rt.skipCancelForNextCreate = false;
        if (msg.response_id) rt.allowedResponseIds.delete(msg.response_id);
        clearTimeout(ragTimer);
        return;
      }

      // Avslut/fel ‚Üí st√§da state
      if (msg.type === 'response.completed' || msg.type === 'response.error') {
        rt._ragBusy = false;
        rt.cancelAutos = false;
        rt.skipCancelForNextCreate = false;
        if (msg.response_id) rt.allowedResponseIds.delete(msg.response_id);
        clearTimeout(ragTimer);
        return;
      }
    }

    // ========= Helpers f√∂r RAG =========
    function parseArgsSafe(s) { try { return JSON.parse(s || '{}'); } catch { return {}; } }
    function isNumericQuestion(q) {
      const s = (q || '').toLowerCase();
      return /\b(hur m√•nga|antal(?:et)?|how many|number of|count)\b/.test(s);
    }
    function hasAll(words, text) {
      const low = text.toLowerCase();
      return words.every(w => low.includes(w.toLowerCase()));
    }
    function extractNumericAnswer(snippets, keywordsAny = [], keywordsMust = []) {
      let best = null;
      for (const sn of (snippets || [])) {
        const text = (sn.text || '').replace(/\s+/g, ' ').trim();
        const sentences = text.split(/(?<=[\.\!\?:;])\s+/);
        for (const sent of sentences) {
          const m = sent.match(/\b\d{1,4}(?:[.,]\d+)?\b/);
          if (!m) continue;
          if (keywordsMust.length && !hasAll(keywordsMust, sent)) continue;
          let sc = (sn.score || 0);
          const low = sent.toLowerCase();
          for (const kw of keywordsAny) if (low.includes(kw.toLowerCase())) sc += 0.03;
          if (sent.length < 20) sc -= 0.1;
          if (!best || sc > best.sc) best = { sent: sent.trim(), num: m[0], sn, sc };
        }
      }
      return best;
    }
    const DOMAIN_BOOST = ['tapp','givare','sensor','ocme','fels√∂k','format','karusell','ventil'];
    function pickBestSentence(snippets, query) {
      const q = (query||'').toLowerCase();
      const tokens = q.split(/[^a-z√•√§√∂0-9]+/i).filter(t => t.length>2);
      let best = { s: '', score: -1, src: null };
      for (const sn of (snippets||[])) {
        const text = (sn.text||'').replace(/\s+/g,' ').trim();
        const sentences = text.split(/(?<=[\.\!\?:;])\s+/);
        for (const sent of sentences) {
          let sc = (sn.score||0);
          const low = sent.toLowerCase();
          if (/\d/.test(sent)) sc += 0.15;
          for (const t of tokens) if (low.includes(t)) sc += 0.04;
          for (const d of DOMAIN_BOOST) if (low.includes(d)) sc += 0.05;
          if (sent.length < 25) sc -= 0.1;
          if (sc > best.score) best = { s: sent.trim(), score: sc, src: sn };
        }
      }
      return best;
    }

    // NY: gemensam query-resolver
    function resolveQueryFromState(args) {
      let q = (args?.query || '').trim();
      if (!q && (rt._liveUserBuf || '').trim()) q = rt._liveUserBuf.trim();
      if (!q && (rt._lastUserText || '').trim()) q = rt._lastUserText.trim();
      if (!q && (rt._lastQuery || '').trim())    q = rt._lastQuery.trim();
      return q;
    }

    // ========= Tool runners =========
    function speakVerbatim(text) {
      const toSay = `L√ÑS UPP EXAKT (ordagrant) och utan till√§gg: """${text}"""`;
      rt.skipCancelForNextCreate = true; // sl√§pp igenom v√•rt tal
      rt.dc?.send(JSON.stringify({
        type: 'response.create',
        response: { modalities: ['audio','text'], instructions: toSay, metadata: { source: 'rag' } }
      }));
    }

    async function runToolSearchManual(tc) {
      const args = parseArgsSafe(tc.argsText);
      const k = args.k ?? 5;
      const q = resolveQueryFromState(args);

      if (!q) {
        if (tc.tool_call_id) {
          rt.dc?.send(JSON.stringify({
            type: 'response.function_call_output',
            tool_call_id: tc.tool_call_id,
            output: JSON.stringify({ ok:false, error:'missing_query', need_user:true })
          }));
          append(pill('‚ö†Ô∏è search_manual: tom query ‚Üí be om f√∂rtydligande'));
        } else {
          speakVerbatim('Jag uppfattade inte fr√•gan. Kan du s√§ga den igen?');
        }
        rt._ragBusy = false;
        clearTimeout(ragTimer);
        return;
      }

      const body = { query: q, k, topK: k, minSim: args.minSim ?? 0.55 };

      try {
        const data = await fetchJSON('/api/search-manual', {
          method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body)
        });

        append(pill(`RAG: count=${data.count||0}${data.fallback?' (fallback)':''} ‚Ä¢ top1=${(data.snippets?.[0]?.score??0).toFixed(2)} ‚Ä¢ q="${q.slice(0,32)}${q.length>32?'‚Ä¶':''}"`));

        let strict = '';
        let bestSent = '';
        let numeric = null;

        if ((data.count||0) > 0) {
          if (isNumericQuestion(q)) {
            const must=['tapp']; const any=['givare','sensor'];
            const hit = extractNumericAnswer(data.snippets, any, must);
            if (hit?.sent) {
              strict = `Enligt manualen: ${hit.sent}`;
              bestSent = hit.sent;
              numeric = { value: Number((hit.num||'').replace(',','.')), sentence: hit.sent };
            }
          }
          if (!strict) {
            const pick = pickBestSentence(data.snippets, q);
            bestSent = (pick.s || (data.snippets[0].text||'').replace(/\s+/g,' ').trim()).slice(0, 500);
            strict = `Enligt manualen: ${bestSent}`;
          }
        }

        const sources = (data.snippets||[]).slice(0,5).map(s=>({ title: s.title||'manual', idx: s.idx, score: s.score }));
        const out = {
          ok: true,
          strict_answer: strict || undefined,
          best_sentence: bestSent || undefined,
          numeric: numeric || null,
          fallback: !!data.fallback,
          top_score: (data.snippets?.[0]?.score ?? null),
          sources
        };

        if (tc.tool_call_id) {
          // l√§mna tillbaka output till Realtime-modellen
          rt.dc?.send(JSON.stringify({
            type: 'response.function_call_output',
            tool_call_id: tc.tool_call_id,
            output: JSON.stringify(out)
          }));
          append(pill('üì§ Skickade tool-output till modellen'));
        } else {
          // Fallback-l√§ge: prata sj√§lv
          if (out.strict_answer) {
            speakVerbatim(out.strict_answer);
            const s0 = sources[0] || {};
            append(bubble(`${out.strict_answer}\nH√§mtat fr√•n: ${(s0.title||'manual')} ‚Ä¢ idx:${s0.idx ?? '?'} ‚Ä¢ score:${(s0.score??0).toFixed(2)}`,'assistant'));
          } else {
            speakVerbatim('Jag kan inte verifiera det i manualen just nu. Specificera del/omr√•de eller felkod s√• letar jag exakt.');
          }
        }

      } catch (err) {
        console.error('search-manual error', err);
        append(errorBubble('Manual-s√∂k fel: ' + (err?.message || err)));
        if (!tc.tool_call_id) {
          speakVerbatim('Kunde inte n√• manual-s√∂k just nu. F√∂rs√∂k igen strax.');
        } else {
          rt.dc?.send(JSON.stringify({
            type: 'response.function_call_output',
            tool_call_id: tc.tool_call_id,
            output: JSON.stringify({ ok:false, error: 'search-manual failed' })
          }));
        }
      } finally {
        rt._ragBusy = false;
        clearTimeout(ragTimer);
      }
    }

    async function runToolSaveMemory(tc) {
      const args = parseArgsSafe(tc.argsText);
      try {
        await fetch('/api/save-memory', {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ userId: localStorage.getItem('operator_id') || 'kevin', key: args.key, value: args.value })
        });
        rt.skipCancelForNextCreate = true;
        rt.dc?.send(JSON.stringify({
          type:'response.create',
          response:{ modalities:['audio','text'], instructions:`Noterat. Jag sparade minnet: ${args.key} = ${args.value}.`, metadata:{ source:'rag' } }
        }));
      } catch {
        rt.skipCancelForNextCreate = true;
        rt.dc?.send(JSON.stringify({
          type:'response.create',
          response:{ modalities:['audio','text'], instructions:`Jag kunde inte spara minnet just nu.`, metadata:{ source:'rag' } }
        }));
      }
    }

    // ========= Send text manuellt (fallback) =========
    $('#sendTextBtn').onclick = sendQuickText;
    $('#quickText').addEventListener('keydown', e => { if (e.key==='Enter') sendQuickText(); });
    function sendQuickText(){
      const t = $('#quickText').value.trim(); if (!t) return;
      $('#quickText').value=''; append(bubble('‚û§ ' + t, 'user'));
      rt._lastUserText = t; // spara √§ven manuell text
      sendTextToRealtime(t);
    }
    function sendTextToRealtime(text) {
      if (!rt?.dc || rt.dc.readyState !== 'open') { append(pill('Inte ansluten.')); return; }
      rt.dc.send(JSON.stringify({ type: 'input_text', text }));  // l√•t modellen h√∂ra texten (VAD/turn)
      if (text.split(/\s+/).length < 2) return;
      if (!rt._ragBusy && text !== rt._lastQuery) {
        rt._ragBusy = true; rt._lastQuery = text;
        rt.cancelAutos = true;
        clearTimeout(ragTimer);
        ragTimer = setTimeout(() => { rt._ragBusy = false; rt.cancelAutos = false; }, RAG_TIMEOUT_MS);
        runToolSearchManual({ tool_call_id: null, response_id: null, argsText: JSON.stringify({ query: text, k: 5, minSim: 0.55 }) }).finally(()=>{});
      }
    }

    // ========= Manual-test UI =========
    $('#manualBtn').addEventListener('click', testManualSearch);
    $('#manualQuery').addEventListener('keydown', e => { if (e.key==='Enter') testManualSearch(); });
    async function testManualSearch() {
      const q = $('#manualQuery').value.trim();
      if (!q) { append(pill('Skriv en fr√•ga f√∂r manualen.')); return; }
      append(bubble('üîé Manual: ' + q, 'user'));
      try {
        const data = await fetchJSON('/api/search-manual', {
          method:'POST', headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ query: q, k: 5, topK: 5, minSim: 0.55 })
        });
        append(pill(`RAG: count=${data.count||0}${data.fallback?' (fallback)':''} ‚Ä¢ top1=${(data.snippets?.[0]?.score??0).toFixed(2)}`));
        if (!data.count) { append(bubble('Inga tr√§ffar i manualen.', 'assistant')); return; }

        const isNum = isNumericQuestion(q);
        if (isNum) {
          const must=['tapp'], any=['givare','sensor'];
          const hit = extractNumericAnswer(data.snippets, any, must);
          if (hit?.sent) {
            append(bubble(`Enligt manualen: ${hit.sent}\nH√§mtat fr√•n: ${(hit.sn?.title||'manual')} ‚Ä¢ idx:${hit.sn?.idx ?? '?'} ‚Ä¢ score:${(hit.sn?.score??0).toFixed(2)}`,'assistant'));
          } else {
            append(bubble('Kan inte verifiera exakt antal i manualen f√∂r denna fr√•ga. Specificera del/omr√•de eller felkod s√• s√∂ker jag igen.','assistant'));
          }
        } else {
          const pick = pickBestSentence(data.snippets, q);
          const top = pick.src || data.snippets[0];
          const chosen = (pick.s || (top.text||'').replace(/\s+/g,' ').trim()).slice(0,500);
          append(bubble(`${chosen}\nH√§mtat fr√•n: ${(top.title||'manual')} ‚Ä¢ idx:${top.idx ?? '?'} ‚Ä¢ score:${(top.score??0).toFixed(2)}`,'assistant'));
        }

        const lines = data.snippets.map((s,i)=> `#${i+1} ‚Ä¢ ${s.title || 'manual'} ‚Ä¢ idx:${s.idx ?? '?'} ‚Ä¢ score:${(s.score??0).toFixed(2)}\n${s.text}`).join('\n---\n');
        append(bubble(lines, 'assistant'));
      } catch (e) {
        append(errorBubble('Manual-s√∂k fel: ' + e.message));
      }
    }
  </script>
</body>
</html>
