<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ðŸ¦¾ Coach Assistant â€“ Linje 65 (Realtime)</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
    button { margin: 5px; }
    textarea { width: 100%; height: 100px; }
    #log { border: 1px solid #ccc; padding: 10px; height: 200px; overflow-y: auto; }
    #status { color: green; }
  </style>
</head>
<body>

  <h1>ðŸ¦¾ Coach Assistant â€“ Linje 65 (Realtime)</h1>

  <div>
    <label for="operator">OperatÃ¶r:</label>
    <input type="text" id="operator" placeholder="Ange operatÃ¶rsnamn">
    <button id="save-operator">Spara</button>
  </div>

  <button id="connect-btn">Anslut Realtime</button>
  <button id="disconnect-btn" disabled>LÃ¤gg pÃ¥</button>

  <div id="status">Inte ansluten</div>
  <div>Minne: â€”</div>

  <textarea id="chat-input" placeholder="Skriv ditt meddelande hÃ¤r..."></textarea>
  <button id="send-btn" disabled>Skicka</button>

  <button id="test-manual">Testa manual</button>

  <div id="log"></div>

  <footer>
    <p>Realtime-rÃ¶st med WebRTC. Manual/RAG via Supabase. Logg + minne i Supabase (conversations/messages/summary).</p>
  </footer>

  <script>
    // Komplett klientkod fÃ¶r att hantera realtime med tool calls
    let ws = null;
    let token = null;
    let model = null;
    let audioContext = null;
    let mediaStream = null;
    let mediaRecorder = null;
    let audioQueue = [];
    let isPlaying = false;
    let currentArgs = {}; // FÃ¶r att samla function call arguments
    let operatorName = localStorage.getItem('operator') || '';

    const operatorInput = document.getElementById('operator');
    const saveOperatorBtn = document.getElementById('save-operator');
    const connectBtn = document.getElementById('connect-btn');
    const disconnectBtn = document.getElementById('disconnect-btn');
    const statusDiv = document.getElementById('status');
    const chatInput = document.getElementById('chat-input');
    const sendBtn = document.getElementById('send-btn');
    const testManualBtn = document.getElementById('test-manual');
    const logDiv = document.getElementById('log');

    operatorInput.value = operatorName;

    function log(message) {
      logDiv.innerHTML += `<p>${message}</p>`;
      logDiv.scrollTop = logDiv.scrollHeight;
    }

    saveOperatorBtn.addEventListener('click', () => {
      operatorName = operatorInput.value.trim();
      localStorage.setItem('operator', operatorName);
      log(`OperatÃ¶r sparad: ${operatorName}`);
    });

    connectBtn.addEventListener('click', async () => {
      try {
        const res = await fetch('/api/rt-token');
        const data = await res.json();
        if (!res.ok) throw new Error(data.error);
        token = data.token;
        model = data.model;
        connectWebSocket();
      } catch (err) {
        log(`Fel vid hÃ¤mtning av token: ${err.message}`);
      }
    });

    disconnectBtn.addEventListener('click', () => {
      if (ws) ws.close();
      if (mediaRecorder) mediaRecorder.stop();
      if (mediaStream) mediaStream.getTracks().forEach(track => track.stop());
      statusDiv.textContent = 'Inte ansluten';
      connectBtn.disabled = false;
      disconnectBtn.disabled = true;
      sendBtn.disabled = true;
    });

    sendBtn.addEventListener('click', () => {
      const text = chatInput.value.trim();
      if (text && ws) {
        ws.send(JSON.stringify({
          type: 'conversation.item.create',
          item: { type: 'message', role: 'user', content: [{ type: 'text', text }] }
        }));
        ws.send(JSON.stringify({ type: 'response.create' }));
        chatInput.value = '';
        log(`Du: ${text}`);
      }
    });

    testManualBtn.addEventListener('click', async () => {
      const query = prompt('Ange sÃ¶kfrÃ¥ga fÃ¶r manualen:');
      if (!query) return;
      try {
        const res = await fetch('/api/search-manual', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ query, k: 5, minSim: 0 })
        });
        const data = await res.json();
        log(`ManualsÃ¶k: ${JSON.stringify(data.snippets, null, 2)}`);
      } catch (err) {
        log(`Fel vid manualsÃ¶k: ${err.message}`);
      }
    });

    async function connectWebSocket() {
      ws = new WebSocket(`wss://api.openai.com/v1/realtime?model=${model}`, {
        headers: {
          Authorization: `Bearer ${token}`,
          'OpenAI-Beta': 'realtime=v1'
        }
      });

      ws.onopen = async () => {
        statusDiv.textContent = 'Ansluten';
        connectBtn.disabled = true;
        disconnectBtn.disabled = false;
        sendBtn.disabled = false;

        // Uppdatera session om nÃ¶dvÃ¤ndigt, men tools Ã¤r redan i session
        ws.send(JSON.stringify({
          type: 'session.update',
          session: {
            turn_detection: { type: 'server_vad' },
            input_audio_transcription: { model: 'whisper-1' }
          }
        }));

        // Starta mikrofon
        try {
          mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const source = audioContext.createMediaStreamSource(mediaStream);
          mediaRecorder = new MediaRecorder(mediaStream, { mimeType: 'audio/webm;codecs=opus' });
          mediaRecorder.ondataavailable = event => {
            if (event.data.size > 0 && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({
                type: 'input_audio_buffer.append',
                audio: event.data // BehÃ¶ver konvertera till base64 eller hantera binÃ¤rt
              }));
              // Obs: Realtime API fÃ¶rvÃ¤ntar base64 audio i input_audio_buffer.append
              // Konvertera blob till base64
              const reader = new FileReader();
              reader.readAsDataURL(event.data);
              reader.onload = () => {
                const base64 = reader.result.split(',')[1];
                ws.send(JSON.stringify({
                  type: 'input_audio_buffer.append',
                  audio: base64
                }));
              };
            }
          };
          mediaRecorder.start(100); // Skicka audio var 100ms
        } catch (err) {
          log(`Mikrofonfel: ${err.message}`);
        }
      };

      ws.onmessage = async (event) => {
        const data = JSON.parse(event.data);
        console.log(data); // FÃ¶r debugging

        switch (data.type) {
          case 'response.audio.delta':
            // Hantera audio output
            const audioDelta = atob(data.delta); // Base64 till binary
            audioQueue.push(new Uint8Array(audioDelta.split('').map(c => c.charCodeAt(0))));
            if (!isPlaying) playAudioQueue();
            break;

          case 'input_audio_buffer.speech_started':
            // Stoppa audio output vid interrupt
            audioQueue = [];
            if (audioContext) audioContext.suspend();
            break;

          case 'conversation.item.created':
            if (data.item.type === 'message' && data.item.role === 'assistant') {
              log(`Assistant: ${data.item.content[0].text}`);
            }
            break;

          case 'response.function_call_arguments.delta':
            // Samla arguments delta
            const delta = data.delta;
            for (const [key, value] of Object.entries(delta)) {
              if (!currentArgs[data.call_id]) currentArgs[data.call_id] = {};
              if (!currentArgs[data.call_id][key]) currentArgs[data.call_id][key] = '';
              currentArgs[data.call_id][key] += value;
            }
            break;

          case 'response.output_item.done':
            if (data.item.type === 'function_call') {
              const callId = data.item.call_id;
              const name = data.item.name;
              let args;
              try {
                args = JSON.parse(currentArgs[callId] || '{}');
              } catch {
                args = {};
              }
              if (name === 'search_manual') {
                // Exekvera tool
                try {
                  const res = await fetch('/api/search-manual', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                      query: args.query || '',
                      k: args.k || 5,
                      minSim: args.minSim || 0
                    })
                  });
                  const result = await res.json();
                  // Skicka tillbaka output
                  ws.send(JSON.stringify({
                    type: 'conversation.item.create',
                    item: {
                      type: 'function_call_output',
                      call_id: callId,
                      output: JSON.stringify(result)
                    }
                  }));
                  // Generera response
                  ws.send(JSON.stringify({ type: 'response.create' }));
                } catch (err) {
                  log(`Tool fel: ${err.message}`);
                  // Skicka error output
                  ws.send(JSON.stringify({
                    type: 'conversation.item.create',
                    item: {
                      type: 'function_call_output',
                      call_id: callId,
                      output: JSON.stringify({ ok: false, error: err.message })
                    }
                  }));
                  ws.send(JSON.stringify({ type: 'response.create' }));
                }
              }
              // Rensa currentArgs
              delete currentArgs[callId];
            }
            break;

          // Hantera andra events vid behov, t.ex. transcription fÃ¶r logg
          case 'input_audio_buffer.transcription.delta':
            log(`Transkription delta: ${data.delta}`);
            break;

          default:
            // Andra events
            break;
        }
      };

      ws.onclose = () => {
        statusDiv.textContent = 'FrÃ¥nkopplad';
        connectBtn.disabled = false;
        disconnectBtn.disabled = true;
        sendBtn.disabled = true;
      };

      ws.onerror = (err) => {
        log(`WebSocket fel: ${err.message}`);
      };
    }

    async function playAudioQueue() {
      if (audioQueue.length === 0) {
        isPlaying = false;
        return;
      }
      isPlaying = true;
      const buffer = audioQueue.shift();
      try {
        const audioBuffer = await audioContext.decodeAudioData(buffer.buffer);
        const source = audioContext.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(audioContext.destination);
        source.start();
        source.onended = playAudioQueue;
      } catch (err) {
        log(`Audio playback fel: ${err.message}`);
        playAudioQueue();
      }
    }

    // Todo: Hantera minne frÃ¥n Supabase osv, men inte specificerat i problemet
  </script>

</body>
</html>
