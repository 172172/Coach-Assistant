<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Coach Assistant ‚Äì Linje 65 (Realtime)</title>
  <style>
    :root {
      --bg: #0b0f14;
      --panel: #121821;
      --text: #e6edf3;
      --muted: #9fb0c3;
      --accent: #5eead4;
      --danger: #f87171;
      --ok: #86efac;
      --pill: #182232;
    }
    html, body { height: 100%; }
    body {
      margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Noto Sans", "Helvetica Neue", Arial;
      background: radial-gradient(1200px 600px at 20% 0%, #0e1621, #0b0f14 75%);
      color: var(--text);
    }
    .wrap { max-width: 980px; margin: 0 auto; padding: 24px; }
    header { display:flex; align-items:center; justify-content:space-between; gap:16px; margin-bottom: 16px; }
    header .title { font-size: 20px; font-weight: 700; letter-spacing: .3px; }
    .controls { display:flex; flex-wrap: wrap; gap:8px; align-items:center; }
    button { appearance:none; border: none; padding: 10px 14px; border-radius: 12px; cursor:pointer; font-weight: 600; }
    .primary { background: var(--accent); color:#0a0f14; }
    .ghost { background: #0d1520; color: var(--text); border: 1px solid #233146; }
    .danger { background: var(--danger); color: #111; }
    .muted { color: var(--muted); font-size: 13px; }
    .row { display:flex; gap:10px; align-items:center; }
    input[type="text"], input[type="search"] { background:#0d1622; color:var(--text); border:1px solid #243244; border-radius:10px; padding:10px 12px; }
    .pill { background: var(--pill); color: var(--text); padding: 8px 12px; border-radius: 999px; display:inline-block; margin: 6px 6px 0 0; font-size: 12px; border:1px solid #26364a; }
    .panel { background: var(--panel); border: 1px solid #233146; border-radius: 16px; padding: 14px; }
    #output { display:flex; flex-direction: column; gap: 10px; margin-top: 14px; }
    .bubble { background:#0f1722; border:1px solid #213145; border-radius:16px; padding:12px 14px; white-space: pre-wrap; line-height: 1.45; }
    .bubble.user { background:#0f1a27; border-color:#24415a; }
    .bubble.assistant { background:#0f1823; border-color:#2c3f57; }
    .bubble.error { background:#1b0f12; border-color:#4a1f2a; }
    .tag { font-size: 11px; opacity:.8; }
    .status { margin-left: 8px; }
    .vis { height: 10px; background: #0e1420; border-radius: 9999px; overflow: hidden; border:1px solid #213145; }
    .vis > b { display:block; height:100%; width: 6%; background: linear-gradient(90deg,#85f3d5,#4dd4ff); transition: width .08s linear; }
    footer { margin-top: 24px; color: var(--muted); font-size: 12px; }
    .src { font-size:12px; margin-top:6px; color:#bfd7ff; opacity:.9; }
    .flex { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">ü¶æ Coach Assistant ‚Äì Linje 65 (Realtime)</div>
      <div class="controls">
        <div class="row">
          <label class="muted" for="operatorId">Operat√∂r:</label>
          <input id="operatorId" type="text" placeholder="t.ex. kevin" style="width:140px" />
          <button class="ghost" id="saveIdBtn">Spara</button>
        </div>
        <button class="primary" id="rtBtn">Anslut Realtime</button>
        <button class="ghost" id="rtHangup" style="display:none">L√§gg p√•</button>
      </div>
    </header>

    <div class="panel">
      <div class="flex">
        <div id="rtStatus" class="pill">Inte ansluten</div>
        <div id="memStatus" class="pill">Minne: ‚Äî</div>
        <div class="vis" style="flex:1 1 220px; min-width:220px"><b id="micBar"></b></div>
      </div>

      <div class="row" style="margin-top:10px">
        <input id="quickText" type="search" placeholder="Skicka text till assistenten (enter)" style="flex:1" />
        <button class="ghost" id="sendTextBtn">Skicka</button>
      </div>

      <!-- Manuell fels√∂kning av RAG utan Realtime -->
      <div class="row" style="margin-top:10px">
        <input id="manualQuery" type="search" placeholder="Testa manual-s√∂k (t.ex. 'sortbyte i tappen')" style="flex:1" />
        <button class="ghost" id="manualBtn">Testa manual</button>
      </div>

      <div id="output"></div>
    </div>

    <footer>
      Realtime-r√∂st med WebRTC. Manual/RAG via Supabase. Logg + minne i Supabase (conversations/messages/summary).<br>
      <span class="muted">Tips: s√§g "Spara detta" s√• kan assistenten l√§gga i l√•ngtidsminne via save_memory.</span>
    </footer>
  </div>

  <script>
    // ========= UI helpers =========
    const $ = sel => document.querySelector(sel);
    const $$ = sel => Array.from(document.querySelectorAll(sel));

    // ========= Robust fetch -> JSON =========
    async function fetchJSON(url, opts) {
      const r = await fetch(url, opts);
      const text = await r.text();
      let json;
      try { json = JSON.parse(text); }
      catch { throw new Error(`${r.status} ${r.statusText}: ${text.slice(0,200)}`); }
      if (!r.ok || json?.ok === false) throw new Error(json?.error || json?.message || `${r.status} ${r.statusText}`);
      return json;
    }

    function pill(text) { const d = document.createElement('div'); d.className = 'pill'; d.textContent = text; return d; }
    function bubble(text, role='assistant') {
      const d = document.createElement('div'); d.className = 'bubble ' + role; d.textContent = text; return d;
    }
    function errorBubble(text) {
      const d = document.createElement('div'); d.className = 'bubble error'; d.textContent = text; return d;
    }
    function append(el) { $('#output').appendChild(el); el.scrollIntoView({behavior:'smooth', block:'end'}); }

    // ========= Operator ID persistence =========
    const operatorInput = $('#operatorId');
    operatorInput.value = localStorage.getItem('operator_id') || 'kevin';
    $('#saveIdBtn').onclick = () => {
      localStorage.setItem('operator_id', operatorInput.value.trim() || 'kevin');
      append(pill('Operat√∂r sparad: ' + (localStorage.getItem('operator_id'))));
    };

    // ========= Realtime state =========
    let rt = {
      pc:null, dc:null, mic:null, remoteAudio:null, connected:false,
      conversation_id:null, _msgCount:0,
      _ragBusy:false, _lastQuery:"", _lastToolCallId:null
    };
    const toolCalls = new Map(); // tool_call_id -> { name, argsText, launched? }

    // Failsafe-timer f√∂r att aldrig l√•sa fast
    const RAG_TIMEOUT_MS = 8000;
    let ragTimer = null;

    // mic visualizer (simple)
    let micAnalyser, micData;
    function setupMicViz(stream) {
      try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const src = ctx.createMediaStreamSource(stream);
        micAnalyser = ctx.createAnalyser();
        micAnalyser.fftSize = 512; micAnalyser.smoothingTimeConstant = 0.8;
        src.connect(micAnalyser);
        micData = new Uint8Array(micAnalyser.frequencyBinCount);
        const bar = $('#micBar');
        (function loop(){
          if (!micAnalyser) return; micAnalyser.getByteTimeDomainData(micData);
          let peak = 0; for (let i=0;i<micData.length;i++){ const v = Math.abs(micData[i]-128)/128; if (v>peak) peak=v; }
          bar.style.width = Math.min(98, (peak*100*1.6)+6) + '%';
          requestAnimationFrame(loop);
        })();
      } catch(e) {}
    }

    // ========= Logging to Supabase via server =========
    async function logMsg(role, content, modality='voice', payload=null) {
      if (!rt.conversation_id) return;
      try {
        const res = await fetch('/api/memory-log', {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ conversation_id: rt.conversation_id, role, content, modality, payload })
        });
        const txt = await res.text();
        let json = {};
        try { json = JSON.parse(txt); } catch {}
        if (!res.ok || json?.ok === false) {
          append(errorBubble('LOGGNING FEL: ' + (json?.error || res.status + ' ' + res.statusText)));
        }
        rt._msgCount = (rt._msgCount || 0) + 1;
        if (rt._msgCount % 8 === 0) {
          fetch('/api/memory-summarize', {
            method: 'POST', headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ conversation_id: rt.conversation_id })
          }).then(()=> $('#memStatus').textContent = 'Minne: uppdaterat');
        }
      } catch (e) {
        append(errorBubble('LOGGNING FEL: ' + (e?.message || e)));
      }
    }

    // ========= Realtime connect =========
    $('#rtBtn').addEventListener('click', connectRealtime);
    $('#rtHangup').addEventListener('click', hangupRealtime);

    async function connectRealtime() {
      const status = t => $('#rtStatus').textContent = t;
      try {
        // 0) Mic
        rt.mic = await navigator.mediaDevices.getUserMedia({ audio: true });
        setupMicViz(rt.mic);

        // 1) Init/restore conversation & memory
        const memInit = await fetchJSON('/api/memory-init', {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ userId: localStorage.getItem('operator_id') || 'kevin' })
        });
        const conversation_id = memInit.conversation_id;
        const memoryBootstrap = memInit.memoryBootstrap || '';
        rt.conversation_id = conversation_id;
        $('#memStatus').textContent = 'Minne: laddat';

        // 2) RTCPeerConnection
        rt.pc = new RTCPeerConnection();
        rt.mic.getTracks().forEach(t => rt.pc.addTrack(t, rt.mic));

        // 3) Spela modellens ljud
        rt.remoteAudio = new Audio(); rt.remoteAudio.autoplay = true; rt.remoteAudio.playsInline = true; rt.remoteAudio.muted = false;
        rt.pc.ontrack = (e) => { rt.remoteAudio.srcObject = e.streams[0]; };

        // 4) Data channel
        rt.dc = rt.pc.createDataChannel('oai-events');
        rt.dc.onopen = () => {
          const sessUpdate = {
            type: 'session.update',
            session: {
              instructions: `Du √§r Coach Assistant f√∂r Linje 65.
Svara kort (max 2 meningar) och stegvis p√• svenska.
INNAN du svarar: kalla ALLTID funktionen search_manual med anv√§ndarens senaste transkriberade text.
Om manual-s√∂k ger noll tr√§ffar, s√§g att du saknar t√§ckning och f√∂resl√• n√§sta trygga steg.

[Minne & senaste v√§xlingar]
${memoryBootstrap}`,
              // Viktigt f√∂r tal-ut: v√§lj en r√∂st
              voice: 'verse',
              turn_detection: { type: 'server_vad' },
              tool_choice: { type: 'required' },
              tools: [
                {
                  type: 'function',
                  name: 'search_manual',
                  description: 'S√∂k i Linje65-manualdatabasen och returnera tr√§ffar med k√§llor.',
                  parameters: {
                    type: 'object',
                    properties: {
                      query: { type: 'string' },
                      k: { type: 'integer', default: 5 },
                      minSim: { type: 'number', default: 0.6 }
                    },
                    required: ['query']
                  }
                },
                {
                  type: 'function',
                  name: 'save_memory',
                  description: 'Spara stabil fakta/inst√§llning i anv√§ndarens l√•ngtidsminne.',
                  parameters: {
                    type: 'object',
                    properties: { key: { type: 'string' }, value: { type: 'string' } },
                    required: ['key','value']
                  }
                }
              ]
            }
          };
          rt.dc.send(JSON.stringify(sessUpdate));
          append(pill('Realtime ansluten. Prata n√§r som helst.'));
        };

        rt.dc.onmessage = (e) => {
          try { handleRealtimeMessage(JSON.parse(e.data)); } catch(err) { /* ignore non-JSON */ }
        };

        // 5) Token + offer/answer
        const { token, model } = await fetchJSON('/api/rt-token');
        append(pill('Realtime modell: ' + model));
        const offer = await rt.pc.createOffer();
        await rt.pc.setLocalDescription(offer);
        const sdpAnswer = await fetch(`https://api.openai.com/v1/realtime?model=${encodeURIComponent(model)}`, {
          method: 'POST', headers: { Authorization: `Bearer ${token}`, 'Content-Type': 'application/sdp' }, body: offer.sdp
        }).then(r => r.text());
        await rt.pc.setRemoteDescription({ type: 'answer', sdp: sdpAnswer });

        // 6) UI state
        rt.connected = true;
        $('#rtBtn').style.display = 'none';
        $('#rtHangup').style.display = 'inline-block';
        status('Realtime ansluten');
      } catch (e) {
        console.error(e);
        $('#rtStatus').textContent = `Realtime misslyckades: ${e?.message || e}`;
        append(errorBubble('Fel vid anslutning: ' + (e?.message || e)));
      }
    }

    async function hangupRealtime() {
      try {
        rt.dc?.close();
        rt.pc?.getSenders()?.forEach(s => s.track?.stop());
        rt.pc?.close();
        rt.mic?.getTracks()?.forEach(t => t.stop());
        micAnalyser = null;
      } catch {}
      rt = {
        pc:null, dc:null, mic:null, remoteAudio:null, connected:false,
        conversation_id:rt.conversation_id, _msgCount:rt._msgCount,
        _ragBusy:false, _lastQuery:"", _lastToolCallId:null
      };
      $('#rtBtn').style.display = 'inline-block';
      $('#rtHangup').style.display = 'none';
      $('#rtStatus').textContent = 'Inte ansluten';
      append(pill('Samtal avslutat.'));
    }

    // ========= Realtime event handler =========
    function isTranscriptFinalType(t) {
      if (!t) return false;
      // Till√•t b√•de .done och .completed f√∂r audio & text
      return (
        /^input_audio_buffer\.transcript\.(done|completed)$/.test(t) ||
        /^input_text\.(done|completed)$/.test(t)
      );
    }

    function handleRealtimeMessage(msg) {
      // 0) Tool arg deltas
      if (msg.type === 'response.function_call_arguments.delta') {
        const id = msg.id || msg.tool_call_id || msg.response_id || 'unknown';
        const prev = toolCalls.get(id) || { name: msg.name, argsText: '' };
        prev.argsText += (msg.delta || msg.arguments_delta || '');
        prev.name = prev.name || msg.name; toolCalls.set(id, prev);
        return;
      }

      // 0a) DEBUG: visa n√§r modellen triggar verktyg
      if (msg.type === 'response.function_call_arguments.done') {
        const id = msg.id || msg.tool_call_id || 'unknown';
        const tc = toolCalls.get(id);
        if (!tc) return;

        try {
          const args = JSON.parse(tc.argsText || '{}');
          if (tc.name) append(pill(`TOOL CALL ‚Üí ${tc.name} q="${String(args.query||'').slice(0,32)}${(args.query||'').length>32?'‚Ä¶':''}"`));
        } catch {}

        if (tc.name === 'search_manual') {
          if (rt._ragBusy || tc.launched) return;
          tc.launched = true; toolCalls.set(id, tc);
          rt._ragBusy = true;
          rt._lastToolCallId = id;
          clearTimeout(ragTimer);
          ragTimer = setTimeout(() => { rt._ragBusy = false; }, RAG_TIMEOUT_MS);
          return runToolSearchManual(tc).finally(()=>{});
        }
        if (tc.name === 'save_memory') {
          if (tc.launched) return;
          tc.launched = true; toolCalls.set(id, tc);
          return runToolSaveMemory(tc);
        }
        return;
      }

      // 1) Tool call completed ‚Üí execute tool (fallback, om inte redan k√∂rts)
      if (msg.type === 'response.function_call.completed') {
        const id = msg.id || msg.tool_call_id || 'unknown';
        const tc = toolCalls.get(id);
        if (!tc) return;
        if (tc.name === 'search_manual') {
          if (rt._ragBusy || tc.launched) return; // undvik dubbelk√∂rning
          tc.launched = true; toolCalls.set(id, tc);
          rt._ragBusy = true;
          rt._lastToolCallId = id;
          clearTimeout(ragTimer);
          ragTimer = setTimeout(() => { rt._ragBusy = false; }, RAG_TIMEOUT_MS);
          return runToolSearchManual(tc).finally(()=>{});
        }
        if (tc.name === 'save_memory') {
          if (tc.launched) return;
          tc.launched = true; toolCalls.set(id, tc);
          return runToolSaveMemory(tc);
        }
        return;
      }

      // 2) User transcript (final) ‚Äî FALLBACK: k√∂r manual-s√∂k EN g√•ng per tur
      if (isTranscriptFinalType(msg.type)) {
        const text = (msg.transcript || msg.text || '').trim();
        if (text) {
          append(bubble(text, 'user'));
          logMsg('user', text, 'voice', msg);

          // hoppa RAG f√∂r enstavigt (hej, tjena, ok)
          if (text.split(/\s+/).length < 2) return;

          if (!rt._ragBusy && text !== rt._lastQuery) {
            rt._ragBusy = true;
            rt._lastQuery = text;
            clearTimeout(ragTimer);
            ragTimer = setTimeout(() => { rt._ragBusy = false; }, RAG_TIMEOUT_MS);
            // ‚¨áÔ∏è s√§nk tr√∂skel + skicka √§ven topK
            runToolSearchManual({ argsText: JSON.stringify({ query: text, k: 5, minSim: 0.4 }) }).finally(()=>{});
          }
        }
        return;
      }

      // 3) Assistant final text ‚Üí sl√§pp l√•set
      if (msg.type === 'response.output_text.done') {
        const text = msg.output_text || msg.text || '';
        if (text?.trim()) {
          append(bubble(text, 'assistant'));
          logMsg('assistant', text, 'voice', msg);
          const idx = text.indexOf('H√§mtat fr√•n:');
          if (idx !== -1) {
            const list = text.slice(idx + 'H√§mtat fr√•n:'.length).trim();
            append(pill('H√§mtat fr√•n:')); const d = document.createElement('div'); d.className='src'; d.innerHTML = list.replaceAll('\n','<br>'); append(d);
          }
        }
        rt._ragBusy = false;     // sl√§pp l√•set
        clearTimeout(ragTimer);
        return;
      }

      // 3b) Helt klart / fel ‚Üí sl√§pp l√•set √§nd√•
      if (msg.type === 'response.completed' || msg.type === 'response.error') {
        rt._ragBusy = false;
        clearTimeout(ragTimer);
        return;
      }
    }

    // ========= Tools =========
    function parseArgsSafe(s) { try { return JSON.parse(s || '{}'); } catch { return {}; } }

    // Deterministiskt RAG-svar + DIAG-chip
    async function runToolSearchManual(tc) {
      const args = parseArgsSafe(tc.argsText);
      const k = args.k ?? 5;
      // ‚¨áÔ∏è skicka b√•de k och topK + l√§gre tr√∂skel initialt
      const body = { query: args.query, k, topK: k, minSim: args.minSim ?? 0.4 };
      try {
        const data = await fetchJSON('/api/search-manual', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });

        // Visa diagnostik i UI s√• vi SER att s√∂ket k√∂rdes (inkl. fallback-info)
        append(pill(`RAG: count=${data.count||0}${data.fallback?' (fallback)':''} ‚Ä¢ model=${data.model||'?'} ‚Ä¢ dims=${data.dims||'?'} ‚Ä¢ q="${(args.query||'').slice(0,32)}${(args.query||'').length>32?'‚Ä¶':''}"`));

        if ((data.count || 0) > 0) {
          const weak = data.fallback === true;
          const top = data.snippets[0] || {};
          const txt = (top.text || '').replace(/\s+/g, ' ').trim();
          const preview = txt.length > 350 ? txt.slice(0, 350) + '‚Ä¶' : txt;
          const sourcesList = (data.snippets || []).map((s,i) =>
            `[#${i+1} | ${(s.title || 'manual')} ‚Ä¢ idx:${s.idx ?? '?'} ‚Ä¢ score:${(s.score??0).toFixed(2)}]`
          ).join('\n');

          const lead = weak
            ? 'Jag hittar inga starka tr√§ffar. B√§sta match just nu:'
            : 'Enligt manualen:';

          let answer = `${lead} ${preview}\nH√§mtat fr√•n: ${(top.title || 'manual')} ‚Ä¢ idx:${top.idx ?? '?'} ‚Ä¢ score:${(top.score ?? 0).toFixed(2)}`;
          if (weak) {
            answer += `\n(obs: svag matchning ‚Äì s√§g g√§rna fler detaljer, t.ex. maskin/omr√•de/format, s√• hittar jag b√§ttre.)`;
          }

          rt.dc?.send(JSON.stringify({
            type: 'response.create',
            response: { modalities: ['audio','text'], instructions: answer + (sourcesList?`\n${sourcesList}`:'') }
          }));
        } else {
          rt.dc?.send(JSON.stringify({
            type: 'response.create',
            response: {
              modalities: ['audio','text'],
              instructions: 'Jag hittar inget i manualen om det d√§r just nu. S√§g g√§rna samma sak med fler detaljer (maskin/omr√•de/format), s√• letar jag igen.'
            }
          }));
        }
      } catch (err) {
        console.error('search-manual error', err);
        append(errorBubble('Manual-s√∂k fel: ' + (err?.message || err)));
        rt.dc?.send(JSON.stringify({
          type: 'response.create',
          response: {
            modalities:['audio','text'],
            instructions: 'Kunde inte n√• manual-s√∂k just nu. F√∂rs√∂k igen strax.'
          }
        }));
        rt._ragBusy = false; // Sl√§pp l√•set s√• man kan f√∂rs√∂ka igen
        clearTimeout(ragTimer);
      }
    }

    async function runToolSaveMemory(tc) {
      const args = parseArgsSafe(tc.argsText);
      try {
        await fetch('/api/save-memory', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ userId: localStorage.getItem('operator_id') || 'kevin', key: args.key, value: args.value })
        });
        rt.dc?.send(JSON.stringify({ type:'response.create', response:{ modalities:['audio','text'], instructions:`Noterat. Jag sparade minnet: ${args.key} = ${args.value}.` } }));
      } catch (e) {
        rt.dc?.send(JSON.stringify({ type:'response.create', response:{ modalities:['audio','text'], instructions:`Jag kunde inte spara minnet just nu.` } }));
      }
    }

    // ========= Send text manually =========
    $('#sendTextBtn').onclick = sendQuickText;
    $('#quickText').addEventListener('keydown', e => { if (e.key==='Enter') sendQuickText(); });
    function sendQuickText(){
      const t = $('#quickText').value.trim(); if (!t) return;
      $('#quickText').value=''; append(bubble('‚û§ ' + t, 'user'));
      sendTextToRealtime(t);
    }
    function sendTextToRealtime(text) {
      if (!rt?.dc || rt.dc.readyState !== 'open') { append(pill('Inte ansluten.')); return; }
      rt.dc.send(JSON.stringify({ type: 'input_text', text }));  // skickas f√∂r VAD/turn mgmt
      if (text.split(/\s+/).length < 2) return; // hoppa RAG f√∂r enstavigt
      if (!rt._ragBusy && text !== rt._lastQuery) {
        rt._ragBusy = true;
        rt._lastQuery = text;
        clearTimeout(ragTimer);
        ragTimer = setTimeout(() => { rt._ragBusy = false; }, RAG_TIMEOUT_MS);
        // ‚¨áÔ∏è skicka topK och l√§gre tr√∂skel
        runToolSearchManual({ argsText: JSON.stringify({ query: text, k: 5, minSim: 0.4 }) }).finally(()=>{});
      }
    }

    // ========= Manual-test UI (direkt mot /api/search-manual) =========
    $('#manualBtn').addEventListener('click', testManualSearch);
    $('#manualQuery').addEventListener('keydown', e => { if (e.key==='Enter') testManualSearch(); });
    async function testManualSearch() {
      const q = $('#manualQuery').value.trim();
      if (!q) { append(pill('Skriv en fr√•ga f√∂r manualen.')); return; }
      append(bubble('üîé Manual: ' + q, 'user'));
      try {
        const data = await fetchJSON('/api/search-manual', {
          method:'POST', headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ query: q, k: 5, topK: 5, minSim: 0.4 })
        });
        append(pill(`RAG: count=${data.count||0}${data.fallback?' (fallback)':''} ‚Ä¢ model=${data.model||'?'} ‚Ä¢ dims=${data.dims||'?'}`));
        if (!data.count) {
          append(bubble('Inga tr√§ffar i manualen.', 'assistant'));
          return;
        }
        const lines = data.snippets.map((s,i)=> `#${i+1} ‚Ä¢ ${s.title || 'manual'} ‚Ä¢ idx:${s.idx ?? '?'} ‚Ä¢ score:${(s.score??0).toFixed(2)}\n${s.text}`).join('\n---\n');
        append(bubble(lines, 'assistant'));
      } catch (e) {
        append(errorBubble('Manual-s√∂k fel: ' + e.message));
      }
    }
  </script>
</body>
</html>
