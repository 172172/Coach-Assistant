<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Coach Assistant â€“ Linje 65 (Realtime, Stabil)</title>
  <style>
    :root{--bg:#0b0f14;--panel:#121821;--text:#e6edf3;--muted:#9fb0c3;--accent:#5eead4;--danger:#f87171;--pill:#182232}
    html,body{height:100%}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Noto Sans","Helvetica Neue",Arial;background:radial-gradient(1200px 600px at 20% 0%,#0e1621,#0b0f14 75%);color:var(--text)}
    .wrap{max-width:980px;margin:0 auto;padding:24px}
    header{display:flex;align-items:center;justify-content:space-between;gap:16px;margin-bottom:16px}
    header .title{font-size:20px;font-weight:700;letter-spacing:.3px}
    .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    button{appearance:none;border:none;padding:10px 14px;border-radius:12px;cursor:pointer;font-weight:600}
    .primary{background:var(--accent);color:#0a0f14}
    .ghost{background:#0d1520;color:var(--text);border:1px solid #233146}
    .muted{color:var(--muted);font-size:13px}
    .row{display:flex;gap:10px;align-items:center}
    input[type="text"],input[type="search"]{background:#0d1622;color:#e6edf3;border:1px solid #243244;border-radius:10px;padding:10px 12px}
    .pill{background:var(--pill);color:var(--text);padding:8px 12px;border-radius:999px;display:inline-block;margin:6px 6px 0 0;font-size:12px;border:1px solid #26364a}
    .panel{background:var(--panel);border:1px solid #233146;border-radius:16px;padding:14px}
    #output{display:flex;flex-direction:column;gap:10px;margin-top:14px}
    .bubble{background:#0f1722;border:1px solid #213145;border-radius:16px;padding:12px 14px;white-space:pre-wrap;line-height:1.45}
    .bubble.user{background:#0f1a27;border-color:#24415a}
    .bubble.assistant{background:#0f1823;border-color:#2c3f57}
    .bubble.error{background:#1b0f12;border-color:#4a1f2a}
    .vis{height:10px;background:#0e1420;border-radius:9999px;overflow:hidden;border:1px solid #213145}
    .vis>b{display:block;height:100%;width:6%;background:linear-gradient(90deg,#85f3d5,#4dd4ff);transition:width .08s linear}
    footer{margin-top:24px;color:var(--muted);font-size:12px}
    .flex{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">ðŸ¦¾ Coach Assistant â€“ Linje 65 (Realtime, Stabil)</div>
      <div class="controls">
        <button class="primary" id="rtBtn">Anslut Realtime</button>
        <button class="ghost" id="rtHangup" style="display:none">LÃ¤gg pÃ¥</button>
      </div>
    </header>

    <div class="panel">
      <div class="flex">
        <div id="rtStatus" class="pill">Inte ansluten</div>
        <div class="vis" style="flex:1 1 220px; min-width:220px"><b id="micBar"></b></div>
      </div>

      <div class="row" style="margin-top:10px">
        <input id="quickText" type="search" placeholder="Skicka text till assistenten (enter)" style="flex:1" />
        <button class="ghost" id="sendTextBtn">Skicka</button>
      </div>

      <div id="output"></div>
    </div>

    <footer>
      FlÃ¶de: GPT anropar <code>search_manual</code> â†’ vi svarar med <code>function_call_output</code> â†’ GPT formulerar svaret.
    </footer>
  </div>

  <script>
    // ===== Helpers =====
    const $ = s => document.querySelector(s);
    const append = el => { $('#output').appendChild(el); el.scrollIntoView({behavior:'smooth',block:'end'}); };
    const pill = t => { const d=document.createElement('div'); d.className='pill'; d.textContent=t; return d; };
    const bubble = (t,role='assistant') => { const d=document.createElement('div'); d.className='bubble '+role; d.textContent=t; return d; };
    const errorBubble = t => { const d=document.createElement('div'); d.className='bubble error'; d.textContent=t; return d; };
    async function fetchJSON(url, opts){ const r=await fetch(url,opts); const txt=await r.text(); let j; try{j=JSON.parse(txt)}catch{throw new Error(`${r.status} ${r.statusText}: ${txt.slice(0,200)}`)} if(!r.ok||j?.ok===false) throw new Error(j?.error||j?.message||`${r.status} ${r.statusText}`); return j; }

    // ===== State =====
    let rt = {
      pc:null, dc:null, mic:null, remoteAudio:null, connected:false,
      calls: new Map(),
      lastUserText: '' // anvÃ¤nds som fallback till tool.query
    };

    // mic viz
    let micAnalyser, micData;
    function setupMicViz(stream){
      try{
        const ctx=new (window.AudioContext||window.webkitAudioContext)();
        const src=ctx.createMediaStreamSource(stream);
        micAnalyser=ctx.createAnalyser(); micAnalyser.fftSize=512; micAnalyser.smoothingTimeConstant=0.8;
        src.connect(micAnalyser); micData=new Uint8Array(micAnalyser.frequencyBinCount);
        const bar=$('#micBar');
        (function loop(){
          if(!micAnalyser) return;
          micAnalyser.getByteTimeDomainData(micData);
          let peak=0; for(let i=0;i<micData.length;i++){ const v=Math.abs(micData[i]-128)/128; if(v>peak) peak=v; }
          bar.style.width=Math.min(98,(peak*100*1.6)+6)+'%';
          requestAnimationFrame(loop);
        })();
      }catch{}
    }

    // ===== Connect / Hangup =====
    $('#rtBtn').addEventListener('click', connectRealtime);
    $('#rtHangup').addEventListener('click', hangupRealtime);

    async function connectRealtime(){
      const status=t=>$('#rtStatus').textContent=t;
      try{
        rt.mic = await navigator.mediaDevices.getUserMedia({
          audio: { channelCount:1, noiseSuppression:true, echoCancellation:true, autoGainControl:false, sampleRate:48000 }
        });
        setupMicViz(rt.mic);

        rt.pc=new RTCPeerConnection();
        rt.pc.addTransceiver('audio', { direction:'recvonly' });
        rt.mic.getTracks().forEach(t=>rt.pc.addTrack(t,rt.mic));

        rt.remoteAudio=new Audio(); rt.remoteAudio.autoplay=true; rt.remoteAudio.playsInline=true; rt.remoteAudio.muted=false;
        rt.pc.ontrack=e=>{ rt.remoteAudio.srcObject=e.streams[0]; rt.remoteAudio.play().catch(()=>{}); append(pill('ðŸ”Š Mottar rÃ¶st frÃ¥n assistenten')); };

        rt.dc=rt.pc.createDataChannel('oai-events');
        rt.dc.onopen=()=>{
          rt.dc.send(JSON.stringify({
            type:'session.update',
            session:{
              voice:'verse',
              modalities:['audio','text'],
              turn_detection:{ type:'server_vad', threshold:0.6, silence_duration_ms:550, prefix_padding_ms:200 },
              input_audio_transcription:{ model:'gpt-4o-transcribe', language:'sv' },
              tool_choice:'auto',
              // BÃ¤lte & hÃ¤ngslen: registrera verktyget hÃ¤r ocksÃ¥
              tools: [
                {
                  type: 'function',
                  name: 'search_manual',
                  description: 'SÃ¶k i manualen och returnera snippets.',
                  parameters: {
                    type: 'object',
                    properties: {
                      query: { type: 'string' },
                      k: { type: 'integer' },
                      minSim: { type: 'number' },
                      heading: { type: 'string' },
                      restrictToHeading: { type: 'boolean' }
                    },
                    required: ['query']
                  }
                }
              ],
              instructions: 'Anropa alltid search_manual fÃ¶rst och svara endast baserat pÃ¥ snippets.'
            }
          }));
          append(pill('Realtime ansluten.'));
        };
        rt.dc.onmessage=(e)=>{ try{ handleRealtimeMessage(JSON.parse(e.data)); }catch(err){ console.warn('parse',err); } };

        const {token, model}=await fetchJSON('/api/rt-token');
        append(pill('Realtime modell: '+model));
        const offer=await rt.pc.createOffer(); await rt.pc.setLocalDescription(offer);
        const sdp=await fetch(`https://api.openai.com/v1/realtime?model=${encodeURIComponent(model)}`,{
          method:'POST',
          headers:{Authorization:`Bearer ${token}`,'Content-Type':'application/sdp','OpenAI-Beta':'realtime=v1'},
          body:offer.sdp
        }).then(r=>r.text());
        await rt.pc.setRemoteDescription({type:'answer', sdp});

        rt.connected=true; $('#rtBtn').style.display='none'; $('#rtHangup').style.display='inline-block'; status('Realtime ansluten');
      }catch(e){ console.error(e); $('#rtStatus').textContent=`Realtime misslyckades: ${e?.message||e}`; append(errorBubble('Fel vid anslutning: '+(e?.message||e))); }
    }

    async function hangupRealtime(){
      try{
        rt.dc?.close();
        rt.pc?.getSenders()?.forEach(s=>s.track?.stop());
        rt.pc?.close(); rt.mic?.getTracks()?.forEach(t=>t.stop());
        micAnalyser=null;
      }catch{}
      rt={ pc:null, dc:null, mic:null, remoteAudio:null, connected:false, calls:new Map(), lastUserText:'' };
      $('#rtBtn').style.display='inline-block'; $('#rtHangup').style.display='none'; $('#rtStatus').textContent='Inte ansluten'; append(pill('Samtal avslutat.'));
    }

    // ===== Text input â†’ assistant =====
    $('#sendTextBtn').onclick = sendQuickText;
    $('#quickText').addEventListener('keydown', e => { if(e.key==='Enter') sendQuickText(); });
    function sendQuickText(){
      const t=$('#quickText').value.trim(); if(!t) return;
      rt.lastUserText = t; // spara sÃ¥ tool alltid har nÃ¥got
      $('#quickText').value=''; append(bubble('âž¤ '+t,'user'));
      if(!rt?.dc || rt.dc.readyState!=='open'){ append(pill('Inte ansluten.')); return; }
      rt.dc.send(JSON.stringify({ type:'input_text', text:t }));
    }

    // ===== Tool call plumbing =====
    function handleRealtimeMessage(msg){
      // FÃ¥nga transkript i realtid â†’ sÃ¥ vi alltid har en fallback
      if (msg.type === 'response.input_audio_transcription.delta') {
        const t = (msg.delta || msg.text || '').trim();
        if (t) rt.lastUserText = t;
      }
      if (
        msg.type === 'response.input_audio_transcription.done' ||
        msg.type === 'response.input_audio_transcription.completed'
      ) {
        const t = (msg.transcript || msg.text || msg.output_audio_transcription || '').trim();
        if (t) rt.lastUserText = t;
      }

      // Visa meddelanden
      if (msg.type==='conversation.item.created'){
        if (msg.item?.role==='user'){
          const parts=msg.item?.content||[];
          for (const p of parts){
            const text = p?.text || p?.transcript || p?.input_text || p?.input_audio_transcription?.text;
            if (typeof text === 'string' && text.trim()){
              rt.lastUserText = text.trim(); // spara senaste texten
              append(bubble(text,'user'));
            }
          }
        }
        if (msg.item?.role==='assistant'){
          const parts=msg.item?.content||[];
          for (const p of parts){
            const text = p?.text || p?.output_text;
            if (typeof text === 'string' && text.trim()) append(bubble(text,'assistant'));
          }
        }
      }

      // Samla ihop tool-argument â€” ALLTID nyckla pÃ¥ tool_call_id
      if (msg.type==='response.function_call_arguments.delta'){
        const key = msg.tool_call_id ?? msg.id ?? msg.response_id ?? 'unknown';
        const prev = rt.calls.get(key) || { name: msg.name, argsText: '', tool_call_id: key };
        prev.argsText += (msg.delta || msg.arguments_delta || '');
        prev.name = prev.name || msg.name;
        rt.calls.set(key, prev);
        return;
      }

      // KÃ¶r verktyget nÃ¤r argumenten Ã¤r klara â€” samma nyckel + skicka tool_call_id vidare
      if (msg.type==='response.function_call_arguments.done'){
        const key = msg.tool_call_id ?? msg.id ?? msg.response_id ?? 'unknown';
        const tc = rt.calls.get(key) || { name: msg.name, argsText: '', tool_call_id: key };
        let args={}; try{ args=JSON.parse(tc.argsText||'{}'); }catch{ args={}; }

        const effectiveQuery = String(args?.query||'').trim() || String(rt.lastUserText||'').trim();
        if (!args.query && effectiveQuery) args.query = effectiveQuery;

        const shown = (effectiveQuery||'').slice(0,48)+((effectiveQuery||'').length>48?'â€¦':'');
        append(pill(`TOOL CALL â†’ ${tc.name} q="${shown}"`));

        if (tc.name==='search_manual'){
          runSearchManualTool(tc.tool_call_id, args)  // viktigt: skicka tool_call_id
            .catch(err=>append(errorBubble('Tool fel: '+(err?.message||String(err)))));
          return;
        }
      }

      // Visa fÃ¤rdiga textsvar
      if (msg.type==='response.output_text.done'){
        const text=msg.output_text||msg.text||'';
        if (text?.trim()) append(bubble(text,'assistant'));
        return;
      }
    }

    async function runSearchManualTool(toolCallId, args) {
      console.log('Tool args:', args);

      // Fallback: anvÃ¤nd senaste text om modellen glÃ¶mde query
      const q = String(args?.query||'').trim() || String(rt.lastUserText||'').trim();

      if (!q) {
        console.warn('Empty args or query (efter fallback)');
        const fallbackResponse = {
          ok: false,
          snippets: [{
            text: "Jag saknar en frÃ¥ga att sÃ¶ka pÃ¥. SÃ¤g t.ex. 'Hur gÃ¶r man formatbyte i OCME?'",
            heading: "HjÃ¤lp",
            score: 0
          }],
        };

        // âœ… RÃ¤tt retur: conversation.item.create + response.create
        rt.dc?.send(JSON.stringify({
          type: 'conversation.item.create',
          item: {
            type: 'function_call_output',
            call_id: toolCallId,
            output: JSON.stringify(fallbackResponse)
          }
        }));
        rt.dc?.send(JSON.stringify({ type:'response.create' }));
        console.log('â†’ sent function_call_output (fallback) & response.create');
        return fallbackResponse;
      }

      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 20000);

        const params = {
          query: q,
          k: typeof args?.k === 'number' ? args.k : 5,
          minSim: typeof args?.minSim === 'number' ? args.minSim : 0.3,
          heading: args?.heading || null,
          restrictToHeading: !!args?.restrictToHeading
        };

        const response = await fetch('/api/search-manual', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(params),
          signal: controller.signal
        });
        clearTimeout(timeoutId);

        let data;
        try { data = await response.json(); }
        catch { data = { ok:false, snippets:[], error:'Ogiltigt svar frÃ¥n servern' }; }

        if (!data.snippets) data.snippets = [];

        rt.dc?.send(JSON.stringify({
          type: 'conversation.item.create',
          item: {
            type: 'function_call_output',
            call_id: toolCallId,
            output: JSON.stringify(data)
          }
        }));
        rt.dc?.send(JSON.stringify({ type:'response.create' }));
        console.log('â†’ sent function_call_output & response.create', data);
        return data;
      } catch (error) {
        console.error('Search tool error:', error);
        const errorResponse = {
          ok: false,
          snippets: [{
            text: "Ett tekniskt fel uppstod vid sÃ¶kning i manualen.",
            heading: "Fel",
            score: 0
          }],
          error: error.toString()
        };
        rt.dc?.send(JSON.stringify({
          type: 'conversation.item.create',
          item: {
            type: 'function_call_output',
            call_id: toolCallId,
            output: JSON.stringify(errorResponse)
          }
        }));
        rt.dc?.send(JSON.stringify({ type:'response.create' }));
        console.log('â†’ sent function_call_output (error) & response.create');
        return errorResponse;
      }
    }
  </script>
</body>
</html>
