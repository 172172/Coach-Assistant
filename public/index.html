<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Coach Assistant ‚Äî Debug</title>
  <link rel="icon" href="data:,">
  <style>
    :root { --bg:#0b0b0f; --fg:#fff; --acc:#00aaff; --mut:#b9c0c7; }
    body { font-family: system-ui, sans-serif; padding: 2rem; background: var(--bg); color: var(--fg); }
    .row { display:flex; gap:.6rem; align-items:center; flex-wrap:wrap; }
    button { padding:.7rem 1rem; font-size:1rem; border:none; border-radius:10px; cursor:pointer; background:var(--acc); color:#fff; }
    #output { margin-top: 1rem; font-size:1.05rem; }
    .status { font-size:.95rem; color:#cfd6dd }
    .pill { background:#12141a; border:1px solid #232733; padding:.75rem .9rem; border-radius:12px; margin-top:.6rem }
    .dot { width:10px; height:10px; border-radius:50%; display:inline-block; margin-right:.5rem; vertical-align:middle }
    .listen { background:#22c55e } .think{ background:#facc15 } .speak{ background:#60a5fa } .idle{ background:#6b7280 }
    #vizWrap { margin-top:1rem; background:#0f1220; border:1px solid #20263a; border-radius:16px; padding:.5rem; }
    canvas { width:100%; height:140px; display:block; border-radius:12px; background:linear-gradient(180deg,#0f1220,#0b0c14); }
    .src { font-size:.85rem; color:#9aa3ad; margin-top:.3rem }
    .opts { display:flex; gap:.5rem; flex-wrap:wrap; margin-top:.5rem }
    .opt { padding:.4rem .6rem; border-radius:10px; border:1px solid #2a3040; background:#171b27; cursor:pointer; }
    .link { color:#8ecbff; cursor:pointer; text-decoration:underline; }
    .muted { color:#9aa3ad; font-size:.9rem; }
    #debug { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:.85rem; white-space:pre-wrap; background:#0c101a; border:1px dashed #2a3040; border-radius:10px; padding:.6rem; margin-top:.8rem; color:#a7b3c2; max-height:220px; overflow:auto; }
    .warn { color:#ffd166 }
    .err { color:#ff6b6b }
    select { padding:.45rem .6rem; border-radius:8px; background:#10131c; color:#e6edf5; border:1px solid #2a3040; }
  </style>
</head>
<body>
  <h1>Coach Assistant</h1>
  <p class="status"><span class="dot idle"></span><span id="recStatus">Redo ‚Äì tryck start. Om inget h√§nder, k√∂r ‚ÄúTesta mic (2s)‚Äù och kika p√• debug nedan.</span></p>

  <div class="row">
    <button id="startBtn">‚ñ∂Ô∏è Starta r√∂stloop</button>
    <button id="stopBtn" style="background:#ef4444;display:none">‚èπÔ∏è Stoppa</button>
    <button id="testBtn" style="background:#6b5bff">üéôÔ∏è Testa mic (2s)</button>
    <span id="secureHint" class="warn" style="margin-left:.5rem;"></span>
  </div>

  <div class="row" style="margin-top:.6rem">
    <label for="micSel">Mikrofon:</label>
    <select id="micSel"></select>
    <span id="permState" class="muted"></span>
  </div>

  <div id="vizWrap"><canvas id="viz" width="800" height="140"></canvas></div>
  <div id="output"></div>
  <div id="debug" class="pill"></div>

  <script>
    const DEBUG_UI = true;
    function dlog(...args){ console.log("[DBG]", ...args); if(!DEBUG_UI) return;
      const el = document.getElementById('debug');
      const line = args.map(a => (typeof a==='object'? JSON.stringify(a): String(a))).join(' ');
      el.textContent += line + "\\n";
      el.scrollTop = el.scrollHeight;
    }

    const startBtn = document.getElementById('startBtn');
    const stopBtn  = document.getElementById('stopBtn');
    const testBtn  = document.getElementById('testBtn');
    const micSel   = document.getElementById('micSel');
    const permState= document.getElementById('permState');
    const output   = document.getElementById('output');
    const recStatus= document.getElementById('recStatus');
    const secureHint = document.getElementById('secureHint');
    const canvas   = document.getElementById('viz');
    const ctx      = canvas.getContext('2d');

    // ---------- STATE ----------
    let state = 'IDLE', running = false;
    let profileName = localStorage.getItem('coach_profile') || null;

    // Mic / analyser
    let micStream = null, mediaRecorder = null, chunks = [];
    let audioCtxVAD = null, analyser = null, micArr = null;

    // TTS (stream)
    let ttsCtx = null, ttsGainNode = null, ttsAnalyser = null;
    let ttsAudio = null;
    const TTS_BASE_GAIN = 0.9, TTS_DUCK_GAIN = 0.22;

    // Loop timers
    let rafId = null;

    // VAD (enkel)
    const SILENCE_HOLD_MS   = 800;
    const MAX_RECORD_MS     = 10000;

    // MIME fallback-order
    const MIME_CANDIDATES = [
      'audio/webm;codecs=opus',
      'audio/webm',
      'audio/mp4',
      'audio/ogg',
      '' // l√•t browsern v√§lja
    ];
    let REC_MIME = '';
    let REC_EXT  = 'webm';

    // Minigr√§nser (v√§ldigt sn√§llt)
    const MIN_SPEECH_MS  = 140;
    const MIN_BLOB_BYTES = 800;

    // hallu-kill
    const HALLUCINATION_PATTERNS = /(patreon|prenumerera|videon|undertexter|amara\.org)/i;

    // ---------- UI helpers ----------
    function setStatus(mode, text) {
      const dotClass = mode === 'LISTENING' ? 'listen' : mode === 'THINKING' ? 'think' : mode === 'SPEAKING' ? 'speak' : 'idle';
      recStatus.previousElementSibling.className = `dot ${dotClass}`;
      recStatus.textContent = text + (profileName ? `  ‚Ä¢ Profil: ${profileName}` : '');
    }

    function trySetProfileFrom(text) {
      const t=(text||'').toLowerCase();
      const m=t.match(/\b(det √§r|de e|det e|jag heter|mitt namn √§r)\s+([a-z√•√§√∂\- ]{2,})/i);
      if (m){ const name=m[2].trim().split(/\s+/)[0]; if(name){ profileName=name.charAt(0).toUpperCase()+name.slice(1); localStorage.setItem('coach_profile',profileName); output.insertAdjacentHTML('beforeend',`<div class="pill">Profil aktiverad: <strong>${profileName}</strong></div>`); return true; } }
      if (/\b(gl√∂m min profil|ta bort profil)\b/i.test(t)){ profileName=null; localStorage.removeItem('coach_profile'); output.insertAdjacentHTML('beforeend',`<div class="pill">Profil rensad ‚Äì neutral stil.</div>`); return true; }
      return false;
    }

    // ---------- Visualizer ----------
    function rmsLevel(uint8PCM) {
      let sum=0; for (let i=0;i<uint8PCM.length;i++){ const v=uint8PCM[i]-128; sum+=v*v; }
      const rms=Math.sqrt(sum/uint8PCM.length);
      return Math.min(255, Math.max(0, Math.round(rms*6)));
    }
    function drawViz(micLevel, ttsLevel){
      const w=canvas.width, h=canvas.height;
      ctx.clearRect(0,0,w,h);
      const g=ctx.createLinearGradient(0,0,0,h);
      g.addColorStop(0,'#0e1222'); g.addColorStop(1,'#0a0d18'); ctx.fillStyle=g; ctx.fillRect(0,0,w,h);
      const base = state==='SPEAKING'? ttsLevel : micLevel;
      const amp  = Math.min(1, base/50);
      const cx=w*0.5, cy=h*0.56, radius=26+amp*18;
      ctx.beginPath();
      for(let i=0;i<64;i++){
        const ang=(i/64)*Math.PI*2;
        const r=radius + Math.sin(ang*3)*4*amp + Math.cos(ang*2.2)*3*amp;
        const x=cx+Math.cos(ang)*r, y=cy+Math.sin(ang)*r;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath();
      const blobGrad=ctx.createRadialGradient(cx,cy,radius*0.3,cx,cy,radius*1.1);
      blobGrad.addColorStop(0, state==='SPEAKING'?'#63b3ff':'#3fe08a'); blobGrad.addColorStop(1,'#0b1022');
      ctx.fillStyle=blobGrad; ctx.fill();
    }

    function loop(){
      let micLevel = 0, ttsLevel = 0;
      if (analyser && micArr){ analyser.getByteTimeDomainData(micArr); micLevel = rmsLevel(micArr); }
      if (ttsAnalyser){
        const arr = new Uint8Array(ttsAnalyser.fftSize);
        ttsAnalyser.getByteTimeDomainData(arr);
        ttsLevel = rmsLevel(arr);
      }
      drawViz(micLevel, ttsLevel);
      rafId = requestAnimationFrame(loop);
    }

    // ---------- TTS (stream via /api/tts-stream) ----------
    function stopTTS(){
      try { if (ttsAudio) { ttsAudio.pause(); ttsAudio.src = ""; ttsAudio.load(); } } catch {}
      ttsAudio = null; ttsAnalyser = null;
      if (ttsCtx) { try { ttsCtx.close(); } catch {} }
      ttsCtx = null; ttsGainNode = null;
    }
    async function speak(text){
      stopTTS(); state='SPEAKING'; setStatus(state,'Svarar‚Ä¶ (prata f√∂r att avbryta)');
      try{
        const url = `/api/tts-stream?text=${encodeURIComponent(text)}&latency=3`;
        ttsAudio = new Audio(); ttsAudio.src = url; ttsAudio.preload = "auto"; ttsAudio.crossOrigin = "anonymous";
        ttsCtx = new (window.AudioContext||window.webkitAudioContext)(); await ttsCtx.resume().catch(()=>{});
        ttsGainNode = ttsCtx.createGain(); ttsGainNode.gain.value = TTS_BASE_GAIN;
        const srcNode = ttsCtx.createMediaElementSource(ttsAudio);
        ttsAnalyser = ttsCtx.createAnalyser(); ttsAnalyser.fftSize = 1024;
        srcNode.connect(ttsGainNode).connect(ttsAnalyser).connect(ttsCtx.destination);
        await ttsAudio.play();
        ttsAudio.onended = ()=>{ if(running) startListening(); };
        ttsAudio.onerror = (e)=>{ dlog("TTS error", e); if (running) startListening(); };
      }catch(err){
        dlog("TTS-stream-fel", err); output.insertAdjacentHTML('beforeend',"<div class='pill'>Kunde inte spela upp ljud (stream).</div>");
        if(running) startListening();
      }
    }

    // ---------- Chat ----------
    function renderDetails(cards, followUp){
      const srcNote = (Array.isArray(cards.matched_headings) && cards.matched_headings.length)
        ? `<div class="src">H√§mtat fr√•n: ${cards.matched_headings.join(', ')}</div>` : '';
      return `
        <div class="muted"><strong>Sammanfattning:</strong> ${cards.summary||'‚Äî'}</div>
        ${cards.steps?.length ? `<div class="muted"><strong>Steg:</strong><br>- ${cards.steps.join('<br>- ')}</div>` : ''}
        ${cards.pitfalls?.length ? `<div class="muted"><strong>Fallgropar:</strong><br>- ${cards.pitfalls.join('<br>- ')}</div>` : ''}
        ${cards.explanation ? `<details style="margin-top:.4rem"><summary class="link">F√∂rklaring</summary><div class="muted" style="margin-top:.4rem">${cards.explanation}</div></details>` : ''}
        ${srcNote}
        ${followUp ? `<div style="margin-top:.4rem;opacity:.9"><em>${followUp}</em></div>` : ''}
      `;
    }

    async function askAssistant(text){
      state='THINKING'; setStatus(state,'Bearbetar‚Ä¶');
      output.insertAdjacentHTML('beforeend', `<div class="pill"><strong>Du sa:</strong> ${text}</div>`);
      try{
        const res = await fetch('/api/chat',{
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ message:text, profile: profileName||null, prev: { question: null, assistant: null } })
        });
        const data=await res.json(); if(!res.ok) throw new Error(data?.error || 'Chat-fel');

        let r=data.reply; if(typeof r==='string'){ try{ r=JSON.parse(r); }catch{} }
        if(!r || typeof r!=='object'){ r = { spoken: 'Jag kunde inte formulera ett svar.' }; }

        if (r.need?.clarify) {
          const opts = Array.isArray(r.need.options) ? r.need.options : [];
          const html = `
            <div class="pill">
              <div>${r.need.question || 'Beh√∂ver lite mer info.'}</div>
              ${opts.length ? `<div class="opts">${opts.map(o => `<button class="opt" data-opt="${o}">${o}</button>`).join('')}</div>` : ''}
            </div>`;
          output.insertAdjacentHTML('beforeend', html);
          document.querySelectorAll('.opt').forEach(btn=>{
            btn.addEventListener('click', ()=> askAssistant(btn.getAttribute('data-opt')));
          });
          await speak(r.spoken || r.need.question || 'En sak till‚Ä¶');
          return;
        }

        const bubble = document.createElement('div');
        bubble.className = 'pill';
        const uid = Date.now().toString();
        bubble.innerHTML = `<div>${r.spoken || 'Klart.'}</div>
                            <div style="margin-top:.5rem"><span class="link" id="toggle_${uid}">Visa detaljer</span></div>
                            <div id="details_${uid}" style="display:none;margin-top:.5rem">${renderDetails(r.cards||{}, r.follow_up||'')}</div>`;
        output.appendChild(bubble);

        const toggle = bubble.querySelector(`#toggle_${uid}`);
        const details = bubble.querySelector(`#details_${uid}`);
        toggle.addEventListener('click', ()=>{
          const open = details.style.display !== 'none';
          details.style.display = open ? 'none' : 'block';
          toggle.textContent = open ? 'Visa detaljer' : 'D√∂lj detaljer';
        });

        await speak(r.spoken || 'Okej.');
      }catch(err){
        dlog("Chat-fel", err);
        output.insertAdjacentHTML('beforeend', `<div class="pill">Kunde inte f√• svar fr√•n AI.</div>`);
        if(running) startListening();
      }
    }

    // ---------- Whisper ----------
    async function transcribe(blob){
      const fd = new FormData();
      fd.append('audio', blob, `audio.${REC_EXT}`);
      fd.append('mime', REC_MIME || 'audio/webm');
      const res=await fetch('/api/whisper',{ method:'POST', body: fd });
      const data=await res.json(); if(!res.ok) throw new Error(data?.error || 'Transkriberingsfel');
      return (data.text||'').trim();
    }

    // ---------- LISTEN ----------
    async function startListening(){
      if(!running) return;
      stopTTS();
      state='LISTENING'; setStatus(state,'Lyssnar‚Ä¶ (bli tyst f√∂r att skicka)');
      chunks=[]; const startedAt=performance.now(); let silentMs=0, talkMs=0;

      try{
        mediaRecorder = new MediaRecorder(micStream, REC_MIME ? { mimeType: REC_MIME, audioBitsPerSecond: 128000 } : undefined);
      }catch(e){
        dlog("MediaRecorder start fail w/mime", REC_MIME, e);
        mediaRecorder = new MediaRecorder(micStream); // sista fallback
      }

      mediaRecorder.ondataavailable = (e)=>{ if(e.data.size>0) chunks.push(e.data); };
      mediaRecorder.onstop = async ()=>{
        const type = REC_MIME || (chunks[0]?.type || 'audio/webm');
        const blob = new Blob(chunks, { type });
        dlog("onstop blob", { size: blob.size, type, talkMs });

        if (talkMs < MIN_SPEECH_MS || blob.size < MIN_BLOB_BYTES) {
          dlog("drop: gate", { talkMs, size: blob.size });
          if(running) startListening();
          return;
        }

        try{
          const text = await transcribe(blob);
          dlog("whisper text:", text);
          if (!text || HALLUCINATION_PATTERNS.test(text)) { if(running) startListening(); return; }
          if(!trySetProfileFrom(text)){
            if(text) await askAssistant(text);
            else { output.insertAdjacentHTML('beforeend',"<div class='pill'>H√∂rde inget tydligt. Prova igen.</div>"); if(running) startListening(); }
          } else { if(running) startListening(); }
        }catch(err){
          dlog("Whisper-fel", err);
          output.insertAdjacentHTML('beforeend',"<div class='pill err'>Kunde inte transkribera ljudet.</div>");
          if(running) startListening();
        }
      };
      mediaRecorder.start();

      const vadTimer=setInterval(()=>{
        if (!running || !mediaRecorder || mediaRecorder.state==='inactive'){ clearInterval(vadTimer); return; }
        analyser.getByteTimeDomainData(micArr);
        const lvl = rmsLevel(micArr);
        // dlog("lvl", lvl); // avkommentera vid behov
        if (lvl >= 12) { talkMs += 100; silentMs = 0; }
        else { silentMs += 100; }
        const elapsed = performance.now()-startedAt;
        if (silentMs >= SILENCE_HOLD_MS || elapsed > MAX_RECORD_MS){
          clearInterval(vadTimer);
          try{ mediaRecorder.state!=='inactive' && mediaRecorder.stop(); }catch{}
        }
      },100);
    }

    // ---------- START/STOP ----------
    async function initDevices(){
      if (!navigator.mediaDevices?.enumerateDevices) return;
      const list = await navigator.mediaDevices.enumerateDevices();
      micSel.innerHTML = "";
      list.filter(d=>d.kind==='audioinput').forEach(d=>{
        const opt = document.createElement('option');
        opt.value = d.deviceId; opt.textContent = d.label || `Mikrofon ${micSel.length+1}`;
        micSel.appendChild(opt);
      });
    }

    async function getMicStream(){
      const constraintsBase = {
        audio: { echoCancellation:true, noiseSuppression:true, autoGainControl:false }
      };
      if (micSel.value) constraintsBase.audio.deviceId = { exact: micSel.value };

      // v√§lj f√∂rsta st√∂dda MIME
      REC_MIME = MIME_CANDIDATES.find(m => !m || MediaRecorder.isTypeSupported(m)) || '';
      REC_EXT  = REC_MIME.includes('mp4') ? 'm4a' : REC_MIME.includes('ogg') ? 'ogg' : 'webm';
      dlog("REC_MIME picked:", REC_MIME || "(browser default)");

      micStream = await navigator.mediaDevices.getUserMedia(constraintsBase);
      audioCtxVAD = new (window.AudioContext||window.webkitAudioContext)();
      await audioCtxVAD.resume().catch(()=>{});
      const src = audioCtxVAD.createMediaStreamSource(micStream);
      analyser = audioCtxVAD.createAnalyser(); analyser.fftSize = 2048;
      micArr = new Uint8Array(analyser.fftSize); src.connect(analyser);
      if(!rafId) rafId = requestAnimationFrame(loop);
      dlog("Mic OK. Tracks:", micStream.getTracks().map(t=>({kind:t.kind, enabled:t.enabled, ready:t.readyState})));
    }

    async function startLoop(){
      if(running) return; running=true;
      startBtn.style.display='none'; stopBtn.style.display='inline-block';
      try{
        await getMicStream();
        setStatus('LISTENING','Lyssnar‚Ä¶ (bli tyst f√∂r att skicka)');
        startListening();
      }catch(e){
        dlog("getUserMedia error", e);
        output.insertAdjacentHTML('beforeend', "<div class='pill err'>Mikrofon kunde inte startas (beh√∂righet eller HTTPS?).</div>");
        running=false; startBtn.style.display='inline-block'; stopBtn.style.display='none';
      }
    }

    function stopLoop(){
      running=false; state='IDLE'; setStatus(state,'Stoppad');
      startBtn.style.display='inline-block'; stopBtn.style.display='none';
      if(rafId){ cancelAnimationFrame(rafId); rafId=null; }
      try{ mediaRecorder && mediaRecorder.state!=='inactive' && mediaRecorder.stop(); }catch{}
      try{ analyser && analyser.disconnect(); }catch{}
      try{ audioCtxVAD && audioCtxVAD.close(); }catch{}
      analyser=null; audioCtxVAD=null; micArr=null;
      stopTTS();
      if(micStream){ micStream.getTracks().forEach(t=>t.stop()); micStream=null; }
    }

    // ---------- One-shot MIC TEST (2s) ----------
    async function testMic(){
      dlog("=== MIC TEST start ===");
      try{
        if(!micStream) await getMicStream();
        const mime = MIME_CANDIDATES.find(m => !m || MediaRecorder.isTypeSupported(m)) || '';
        let rec;
        try { rec = new MediaRecorder(micStream, mime ? { mimeType: mime, audioBitsPerSecond: 128000 } : undefined); }
        catch { rec = new MediaRecorder(micStream); }
        const bufs = [];
        rec.ondataavailable = (e)=>{ if(e.data.size) bufs.push(e.data); };
        rec.onstop = async ()=>{
          const type = mime || (bufs[0]?.type || 'audio/webm');
          const blob = new Blob(bufs, { type });
          dlog("MIC TEST blob", { size: blob.size, type });
          output.insertAdjacentHTML('beforeend', `<div class="pill">Mic test ‚Üí ${Math.round(blob.size/1024)} KB, ${type}</div>`);
          try{
            const txt = await transcribe(blob);
            output.insertAdjacentHTML('beforeend', `<div class="pill"><strong>Transkribering:</strong> ${txt || '‚Äî (tom)'}</div>`);
          }catch(err){
            dlog("MIC TEST whisper error", err);
            output.insertAdjacentHTML('beforeend', `<div class="pill err">Transkribering misslyckades: ${err?.message||err}</div>`);
          }
          dlog("=== MIC TEST end ===");
        };
        rec.start();
        setTimeout(()=>{ try{ rec.stop(); }catch{} }, 2000);
      }catch(e){
        dlog("MIC TEST error", e);
        output.insertAdjacentHTML('beforeend', `<div class="pill err">Mic test fail: ${e?.message||e}</div>`);
      }
    }

    // ---------- Permissions / Hints ----------
    (async ()=>{
      if (!isSecureContext && !location.hostname.includes('localhost')) {
        secureHint.textContent = "‚ö†Ô∏è K√∂rs utan HTTPS ‚Äì mic kan blockas. Testa localhost eller https://";
      }
      if (navigator.permissions?.query) {
        try {
          const st = await navigator.permissions.query({name:'microphone'});
          permState.textContent = `Beh√∂righet: ${st.state}`;
          st.onchange = ()=> permState.textContent = `Beh√∂righet: ${st.state}`;
        } catch {}
      }
      await initDevices();
    })();

    // ---------- Events ----------
    startBtn.addEventListener('click', startLoop);
    stopBtn.addEventListener('click', stopLoop);
    testBtn.addEventListener('click', testMic);
    micSel.addEventListener('change', async ()=>{ if(running){ stopLoop(); await startLoop(); } });

    // Manuell avbryt tts
    document.addEventListener('click', ()=>{ if (running && state==='SPEAKING'){ stopTTS(); startListening(); }});
    window.addEventListener('keydown',(e)=>{ if(e.key===' ' && state==='SPEAKING'){ e.preventDefault(); stopTTS(); startListening(); }});
    window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') stopLoop(); });
  </script>
</body>
</html>
