<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Coach Assistant</title>
  <link rel="icon" href="data:,">
  <style>
    :root { --bg:#0b0b0f; --fg:#fff; --acc:#00aaff; --mut:#b9c0c7; }
    body { font-family: system-ui, sans-serif; padding: 2rem; background: var(--bg); color: var(--fg); }
    .row { display:flex; gap:.6rem; align-items:center; flex-wrap:wrap; }
    button { padding:.75rem 1rem; font-size:1rem; border:none; border-radius:12px; cursor:pointer; background:var(--acc); color:#fff; }
    #output { margin-top: 1rem; font-size:1.05rem; }
    .status { font-size:.95rem; color:#cfd6dd }
    .pill { background:#12141a; border:1px solid #232733; padding:.75rem .9rem; border-radius:12px; margin-top:.6rem }
    .dot { width:10px; height:10px; border-radius:50%; display:inline-block; margin-right:.5rem; vertical-align:middle }
    .listen { background:#22c55e } .think{ background:#facc15 } .speak{ background:#60a5fa } .idle{ background:#6b7280 }
    #vizWrap { margin-top:1rem; background:#0f1220; border:1px solid #20263a; border-radius:16px; padding:.5rem; }
    canvas { width:100%; height:140px; display:block; border-radius:12px; background:linear-gradient(180deg,#0f1220,#0b0c14); }
    .src { font-size:.85rem; color:#9aa3ad; margin-top:.3rem }
    .link { color:#8ecbff; cursor:pointer; text-decoration:underline; }
    .muted { color:#9aa3ad; font-size:.9rem; }
    .ghost { background:#2f3542 }
    #debugInput { margin-top:1rem; width:100%; padding:0.75rem; border-radius:12px; border:1px solid #232733; background:#12141a; color:#fff; }
    #debugBtn { margin-top:0.5rem; }
    /* --- Futuristic glass + neon --- */
:root{
  --bg:#06070b; --fg:#e6f0ff; --acc:#6ae1ff; --acc2:#9f7bff; --mut:#b9c0c7;
  --glass: rgba(17,22,34,.55);
  --glass-border: rgba(139,172,255,.18);
  --glow: 0 0 24px rgba(106,225,255,.35), 0 0 48px rgba(159,123,255,.18);
}
body{
  background:
    radial-gradient(1200px 800px at 80% -10%, rgba(159,123,255,.08), transparent 55%),
    radial-gradient(1000px 800px at -10% 110%, rgba(106,225,255,.10), transparent 50%),
    linear-gradient(180deg,#05060a,#090b11 46%, #06070b);
  color: var(--fg);
}

/* Header underline sweep */
h1{
  font-weight:700; letter-spacing:.4px;
  background: linear-gradient(90deg, #fff, #cde8ff 40%, #bfa8ff);
  -webkit-background-clip: text; background-clip: text; color: transparent;
  position: relative; display:inline-block;
}
h1::after{
  content:""; position:absolute; left:0; right:0; bottom:-8px; height:2px;
  background: linear-gradient(90deg, transparent, var(--acc), var(--acc2), transparent);
  filter: blur(.2px); opacity:.6; animation: sweep 2.4s ease-in-out infinite;
}
@keyframes sweep{ 0%{transform:translateX(-30%)} 50%{transform:translateX(30%)} 100%{transform:translateX(-30%)} }

/* Glass panels */
.pill, #vizWrap{
  background: var(--glass);
  border: 1px solid var(--glass-border);
  box-shadow: var(--glow);
  backdrop-filter: blur(10px) saturate(130%);
}

/* Buttons – pill + neon ring */
button{
  position:relative; overflow:hidden;
  background: linear-gradient(180deg,#1a2237,#121826);
  border:1px solid rgba(170,200,255,.25);
  box-shadow: inset 0 0 0 1px rgba(106,225,255,.25), 0 8px 22px rgba(0,0,0,.35);
  transition: transform .12s ease, box-shadow .2s ease, border-color .2s ease;
}
button::before{
  content:""; position:absolute; inset:-2px;
  background: conic-gradient(from 180deg, rgba(106,225,255,.0), rgba(159,123,255,.25), rgba(106,225,255,.0));
  filter: blur(14px); opacity:.0; transition: opacity .2s ease;
}
button:hover{ transform: translateY(-1px); border-color: rgba(170,200,255,.5); }
button:hover::before{ opacity:.55; }
button.ghost{ background: linear-gradient(180deg,#0e1423,#0b101a); }

/* Status-dot glow */
.dot{ box-shadow: 0 0 12px currentColor; opacity:.95 }

/* Futuristic grid bg under visualizer */
#vizWrap{
  position:relative; overflow:hidden;
}
#vizWrap::before, #vizWrap::after{
  content:""; position:absolute; inset:0; pointer-events:none;
}
#vizWrap::before{
  /* subtle grid */
  background:
    linear-gradient(rgba(120,140,180,.08) 1px, transparent 1px),
    linear-gradient(90deg, rgba(120,140,180,.07) 1px, transparent 1px);
  background-size: 28px 28px, 28px 28px;
  mask-image: radial-gradient(70% 100% at 50% 0%, rgba(0,0,0,.95), transparent 75%);
}
#vizWrap::after{
  /* scanning line */
  background: linear-gradient(180deg, transparent, rgba(106,225,255,.08), transparent);
  height: 40%; transform: translateY(-120%); animation: scan 4.2s linear infinite;
}
@keyframes scan{ to{ transform: translateY(220%);} }

/* Output text polish */
#output .pill{ line-height:1.45; }

/* Debug input */
#debugInput{
  background:#0f1424; border-color:#22304a;
}
/* ==== JARVIS MODE ==== */
:root{
  --jarvis-c1:#6ae1ff; --jarvis-c2:#9f7bff; --jarvis-bg0:#05060a; --jarvis-bg1:#0a0f1b;
}
body{
  background:
    radial-gradient(1200px 700px at 90% -10%, rgba(159,123,255,.08), transparent 55%),
    radial-gradient(900px 700px at -10% 110%, rgba(106,225,255,.10), transparent 50%),
    linear-gradient(180deg,var(--jarvis-bg0),var(--jarvis-bg1) 46%, #06070b);
  transition: background .6s ease;
}
body.awake{
  background:
    radial-gradient(1200px 700px at 80% -10%, rgba(159,123,255,.14), transparent 55%),
    radial-gradient(900px 700px at -10% 110%, rgba(106,225,255,.16), transparent 50%),
    linear-gradient(180deg,#070a12,#0b1120 46%, #06070b);
}

/* Headline glow sweep */
h1{
  background: linear-gradient(90deg, #ffffff, #cde8ff 40%, #bfa8ff);
  -webkit-background-clip:text; background-clip:text; color:transparent;
  position:relative; display:inline-block;
}
h1::after{
  content:""; position:absolute; left:0; right:0; bottom:-8px; height:2px;
  background: linear-gradient(90deg, transparent, var(--jarvis-c1), var(--jarvis-c2), transparent);
  filter: blur(.2px); opacity:.55; transform:translateX(-30%);
  animation: sweep 2.6s ease-in-out infinite;
}
@keyframes sweep{ 50%{ transform:translateX(30%);} }

/* Glass panels */
.pill, #vizWrap{
  background: rgba(17,22,34,.55);
  border: 1px solid rgba(139,172,255,.18);
  box-shadow: 0 0 24px rgba(106,225,255,.28), 0 0 48px rgba(159,123,255,.12);
  backdrop-filter: blur(10px) saturate(130%);
  transition: transform .2s ease, box-shadow .2s ease;
}
body.awake #vizWrap{ box-shadow: 0 0 26px rgba(106,225,255,.35), 0 0 60px rgba(159,123,255,.18); }

/* Futuristic grid under visualizer */
#vizWrap{ position:relative; overflow:hidden; }
#vizWrap::before, #vizWrap::after{ content:""; position:absolute; inset:0; pointer-events:none; }
#vizWrap::before{
  background:
    linear-gradient(rgba(120,140,180,.08) 1px, transparent 1px),
    linear-gradient(90deg, rgba(120,140,180,.07) 1px, transparent 1px);
  background-size: 28px 28px, 28px 28px;
  mask-image: radial-gradient(70% 100% at 50% 0%, rgba(0,0,0,.95), transparent 75%);
  opacity:.85;
}
#vizWrap::after{
  background: linear-gradient(180deg, transparent, rgba(106,225,255,.10), transparent);
  height:40%; transform: translateY(-120%);
  animation: scan 4.6s linear infinite;
}
@keyframes scan{ to{ transform: translateY(230%);} }

/* Buttons neon */
button{
  position:relative; overflow:hidden;
  background: linear-gradient(180deg,#1a2237,#121826);
  border:1px solid rgba(170,200,255,.25);
  box-shadow: inset 0 0 0 1px rgba(106,225,255,.25), 0 8px 22px rgba(0,0,0,.35);
  transition: transform .14s ease, border-color .2s ease, box-shadow .2s ease;
}
button:hover{ transform: translateY(-1px); border-color: rgba(170,200,255,.5); }
button.ghost{ background: linear-gradient(180deg,#0e1423,#0b101a); }

/* Status dot glow */
.dot{ box-shadow: 0 0 12px currentColor; }

/* ==== Boot overlay ==== */
#bootFx{ position:fixed; inset:0; pointer-events:none; opacity:0; z-index:999; }
#bootFx.active{ opacity:1; }
#bootFx .boot-flash{
  position:absolute; inset:0;
  background: radial-gradient(circle at 50% 50%, rgba(200,240,255,.55), transparent 55%);
  filter: blur(14px); opacity:0; transform: scale(0.92);
}
#bootFx .boot-vignette{
  position:absolute; inset:0;
  background: radial-gradient(circle at 50% 50%, transparent 45%, rgba(0,0,0,.65));
  opacity:0;
}
#bootFx .boot-scan{
  position:absolute; left:0; right:0; height:18%;
  top:-25%; opacity:0;
  background: linear-gradient(180deg, transparent, rgba(106,225,255,.25), transparent);
  filter: blur(1px);
}

/* boot animations (triggeras via JS) */
#bootFx.flash .boot-flash{ animation: fxFlash .32s ease forwards; }
#bootFx.flash .boot-vignette{ animation: fxVignette .9s ease forwards; }
#bootFx.flash .boot-scan{ animation: fxScan 1.6s ease-out forwards .14s; }

@keyframes fxFlash{
  0%{ opacity:.0; transform:scale(0.92) }
  25%{ opacity:1; transform:scale(1.02) }
  100%{ opacity:0; transform:scale(1) }
}
@keyframes fxVignette{
  0%{ opacity:0 } 20%{ opacity:.6 } 100%{ opacity:0 }
}
@keyframes fxScan{
  0%{ opacity:0; top:-25% }
  10%{ opacity:1 }
  100%{ opacity:0; top:120% }
}
    /* Immersive JARVIS mode */
body.immersive *:not(#vizWrap):not(#vizWrap *):not(#bootFx){ 
  opacity:0; pointer-events:none; 
  transition: opacity .25s ease;
}
body.immersive #vizWrap{
  position:fixed; inset:0; padding:0; margin:0;
  border:none; background:transparent; z-index:999;
}
body.immersive #vizWrap canvas{
  width:100vw; height:100vh; border-radius:0; 
}

/* Undertext / “röst” */
#speechSub{
  position:absolute; left:50%; bottom:6vh; transform:translateX(-50%);
  max-width:min(90vw,1000px);
  padding:.85rem 1.1rem; border-radius:14px;
  background: rgba(10,14,26,.55);
  border: 1px solid rgba(140,170,255,.22);
  backdrop-filter: blur(8px) saturate(130%);
  color:#e6f0ff; font-size:1.05rem; line-height:1.4;
  opacity:0; transition: opacity .18s ease, transform .18s ease;
}
#speechSub.visible{ opacity:1; transform:translateX(-50%) translateY(0); }


  </style>
</head>
<body>
  <h1>Coach Assistant</h1>
  <!-- JARVIS boot-overlay -->
<div id="bootFx" aria-hidden="true">
  <div class="boot-flash"></div>
  <div class="boot-vignette"></div>
  <div class="boot-scan"></div>
</div>

  <p class="status"><span class="dot idle"></span><span id="recStatus">Redo – tryck start. Prata för att avbryta svaret när som helst.</span></p>

  <div class="row">
    <button id="startBtn">▶️ Starta röstloop</button>
    <button id="stopBtn" class="ghost" style="display:none">⏹️ Stoppa</button>
    <button id="abortTTSBtn" class="ghost" style="display:none">⏸️ Avbryt tal</button>
    <button id="reportBtn" class="ghost">📝 Rapportera problem</button>
  </div>

  <div style="margin-top:1rem">
    <label for="volumeSlider" class="muted">Volym:</label>
    <input type="range" id="volumeSlider" min="0" max="1" step="0.1" value="0.9" style="width:200px;">
  </div>

  <div id="vizWrap"><canvas id="viz" width="800" height="140"></canvas></div>
  <div id="speechSub" aria-live="polite"></div>
  <div id="output"></div>

  <input id="debugInput" type="text" placeholder="Skriv en testfråga här (för debugging)" />
  <button id="debugBtn">Skicka text</button>

  <script>
    const startBtn = document.getElementById('startBtn');
    const stopBtn  = document.getElementById('stopBtn');
    const abortBtn = document.getElementById('abortTTSBtn');
    const output   = document.getElementById('output');
    const recStatus= document.getElementById('recStatus');
    const canvas   = document.getElementById('viz');
    const ctx      = canvas.getContext('2d');
    const debugInput = document.getElementById('debugInput');
    const debugBtn = document.getElementById('debugBtn');

    // ---------- STATE ----------
    let state = 'IDLE', running = false;
    let chatHistory = [];

    // Pace (om du tidigare använde den – vi låter standard vara 4)
    let STEP_CHUNK_SIZE = 4;

    // Mic / analyser
    let micStream = null, mediaRecorder = null, chunks = [];
    let audioCtxVAD = null, analyser = null, micArr = null;

    // TTS (stream)
    let ttsCtx = null, ttsGainNode = null, ttsAnalyser = null;
    let ttsAudio = null;
    let lastTTSEnd = 0;
    const TTS_BASE_GAIN = 0.9;

    // Eko-skydd
    let lastSpokenText = "";
    let lastSpokenTextNorm = "";
    const ECHO_SUPPRESS_MS = 2500;      // extra hård filterperiod efter TTS
    const LISTEN_DELAY_AFTER_TTS = 350;

    // Stegvis uppläsning
    let stepQueue = [];
    let stepOffset = 0;
    let lastQ = null, lastA = null;

    // VAD
    const MAX_RECORD_MS   = 10000;
    const SILENCE_HOLD_MS = 800;

    // MIME
    const MIME_CANDIDATES = ['audio/webm;codecs=opus','audio/webm','audio/mp4','audio/ogg',''];
    let REC_MIME = '', REC_EXT = 'webm';

    // Gates
    const MIN_SPEECH_MS       = 160;
    const MIN_SPEECH_MS_ECHO  = 320;
    const MIN_BLOB_BYTES      = 1200;

    // Nytt: “duty cycle” – kräver tillräcklig andel tal i klippet
    const MIN_DUTY            = 0.18;   // 18% av tiden ska vara över tröskeln
    const MIN_DUTY_ECHO       = 0.28;   // hårdare direkt efter TTS

    // Hallu/eko-filter
    const HALLU = /(patreon|prenumerera|videon|undertexter|amara\.org)/i;

    // Fillers vi vill SLÄNGA (vanliga falsk-väckningar på svenska)
    const DISCARD_FILLERS = [
      "tack","tack sa mycket","tack så mycket","tack for mig","tack för mig",
      "ok","okej","mm","mmm","mhm","öh","eh","ah","aha","aa","jaa","yes","jo"
    ];

    // Hälsningar vi VILL TILLÅTA även om de är korta
    const GREETINGS_OK = /^(hej( hej)?|tja|tjena|hall[aå]|god morgon|god kväll)$/i;

    const STEP_COMMANDS = /(nästa|fortsätt|mer|continue|next)/i;

    // ---------- Utils ----------
    function normalize(s){
      return (s||"").toLowerCase()
        .normalize("NFD").replace(/[\u0300-\u036f]/g,"")
        .replace(/[åÅ]/g,"a").replace(/[äÄ]/g,"a").replace(/[öÖ]/g,"o")
        .replace(/[^a-z0-9\s]/g," ")
        .replace(/\s+/g," ").trim();
    }

    // Bedöm om en transkription ska slängas (falsk väckning / brus / kortfiller)
    function shouldDropUtterance(text, talkMs, elapsedMs){
      const withinEcho = (Date.now() - lastTTSEnd) < ECHO_SUPPRESS_MS;
      const duty = talkMs / Math.max(1, elapsedMs);
      const dutyMin = withinEcho ? MIN_DUTY_ECHO : MIN_DUTY;

      const raw = (text||"").trim();
      const norm = normalize(raw);

      if (!norm) return true;                          // tomt
      if (raw.length < 2) return true;                 // extremt kort
      if (DISCARD_FILLERS.includes(norm)) return true; // kända brus-filler
      if (duty < dutyMin) return true;                 // för lite faktisk tal-energi

      // Om väldigt kort och inte fråga: släng, utom hälsningar och stegkommandon
      const words = norm.split(" ").filter(Boolean);
      if (words.length <= 2 && !/[?]/.test(raw) && !GREETINGS_OK.test(raw) && !STEP_COMMANDS.test(raw)) {
        return true;
      }
      return false;
    }

    function setStatus(mode, text) {
      const dot = mode === 'LISTENING' ? 'listen' : mode === 'THINKING' ? 'think' : mode === 'SPEAKING' ? 'speak' : 'idle';
      recStatus.previousElementSibling.className = `dot ${dot}`;
      recStatus.textContent = text;
    }

    // ---------- Viz ----------
    function rmsLevel(uint8PCM) {
      let sum=0; for (let i=0;i<uint8PCM.length;i++){ const v=uint8PCM[i]-128; sum+=v*v; }
      const rms=Math.sqrt(sum/uint8PCM.length);
      return Math.min(255, Math.max(0, Math.round(rms*6)));
    }
   function drawViz(micLevel, ttsLevel){
  const w = canvas.width, h = canvas.height;
  ctx.clearRect(0,0,w,h);

  // Bakgrundsgradient som skiftar lite beroende på state
  const isSpeak = state === 'SPEAKING';
  const g = ctx.createLinearGradient(0,0,0,h);
  g.addColorStop(0, isSpeak ? '#0b1022' : '#0c1120');
  g.addColorStop(1, isSpeak ? '#080c18' : '#070a13');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,w,h);

  // Nivå (mic vs tts) -> 0..255
  const base = isSpeak ? ttsLevel : micLevel;
  const amp  = Math.min(1, base / 52); // 0..1
  const cx = w * 0.5, cy = h * 0.58;

  // Glow-ring (ytterkant)
  const r0 = Math.min(w, h) * 0.22;
  const r  = r0 + amp * 16;
  const ring = ctx.createRadialGradient(cx,cy,r*0.6, cx,cy,r*1.35);
  ring.addColorStop(0, 'rgba(106,225,255,.28)');
  ring.addColorStop(1, 'rgba(159,123,255,.06)');
  ctx.fillStyle = ring;
  ctx.beginPath(); ctx.arc(cx,cy,r*1.2,0,Math.PI*2); ctx.fill();

  // Kärna
  const core = ctx.createRadialGradient(cx,cy,r*0.1, cx,cy,r*0.85);
  core.addColorStop(0, isSpeak ? '#78e9ff' : '#6af0b5');
  core.addColorStop(1, '#0a1024');
  ctx.fillStyle = core;
  ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();

  // “AI sweep arc” – svepande båge som pulserar med nivån
  const t = performance.now() / 1000;
  const arcAmp = 0.6 + amp * 0.6;
  const start = t * 1.6 % (Math.PI * 2);
  ctx.lineWidth = 3 + amp * 2.2;
  const grad = ctx.createLinearGradient(cx - r, cy - r, cx + r, cy + r);
  grad.addColorStop(0, 'rgba(106,225,255,.9)');
  grad.addColorStop(1, 'rgba(159,123,255,.9)');
  ctx.strokeStyle = grad;
  ctx.beginPath();
  ctx.arc(cx, cy, r * 0.78, start, start + Math.PI * arcAmp);
  ctx.stroke();

  // Små partiklar som rör sig runt kärnan
  const dots = 30;
  ctx.fillStyle = 'rgba(200,230,255,.15)';
  for (let i = 0; i < dots; i++){
    const a = (i / dots) * Math.PI * 2 + t * 0.6;
    const pr = r * 0.95 + Math.sin(t * 1.7 + i) * 4 * amp;
    const x = cx + Math.cos(a) * pr;
    const y = cy + Math.sin(a) * pr;
    ctx.fillRect(x, y, 1.5, 1.5);
  }
}
let rafId=null;
function loop(){
  let micLevel = 0, ttsLevel = 0;
  if (analyser && micArr){ analyser.getByteTimeDomainData(micArr); micLevel = rmsLevel(micArr); }
  if (ttsAnalyser){
    const arr = new Uint8Array(ttsAnalyser.fftSize);
    ttsAnalyser.getByteTimeDomainData(arr);
    ttsLevel = rmsLevel(arr);
  }
  drawViz(micLevel, ttsLevel);
  rafId = requestAnimationFrame(loop);
}

// ---------- TTS (stream) ----------
let _speakResolve = null;
function stopTTS(){
  try { if (ttsAudio) { ttsAudio.pause(); ttsAudio.src = ""; ttsAudio.load(); } } catch {}
  ttsAudio = null; ttsAnalyser = null;
  if (ttsCtx) { try { ttsCtx.close(); } catch {} }
  ttsCtx = null; ttsGainNode = null;
  if (_speakResolve) { try { _speakResolve(); } catch {} _speakResolve = null; }
  lastTTSEnd = Date.now();
}
// --- ADD: Adaptiv menings-splitter för TTS (punkt/komma, fall-back på längd) ---
function splitForTTS(text, target = 180, hardMax = 260) {
  const parts = [];
  const sentences = String(text || "").split(/(?<=[.!?])\s+/);

  for (let s of sentences) {
    // om väldigt lång: dela vidare på komma
    if (s.length > hardMax) {
      const subs = s.split(/,\s+/);
      let buf = "";
      for (const sub of subs) {
        if ((buf + (buf ? ", " : "") + sub).length > target) {
          if (buf) parts.push(buf.trim());
          buf = sub;
        } else {
          buf += (buf ? ", " : "") + sub;
        }
      }
      if (buf) parts.push(buf.trim());
    } else {
      parts.push(s.trim());
    }
  }
  // Städa bort tomma
  return parts.filter(Boolean);
}


// --- ADD: Välj TTS-parametrar efter bitens längd (latens & uttryck) ---
function pickTTSParams(str) {
  const n = (str || "").length;
  if (n <= 120) return { latency: 2, stability: 0.50, similarity: 0.90, style: 0.70 };
  if (n <= 280) return { latency: 3, stability: 0.55, similarity: 0.90, style: 0.72 };
  return { latency: 4, stability: 0.60, similarity: 0.90, style: 0.75 };
}

// --- ADD: Spela en bit via streaming för snabb start ---
async function speakStreamChunk(bit, params) {
  stopTTS();
  state='SPEAKING'; setStatus(state,'Svarar…');
  abortBtn.style.display = 'inline-block';
  lastSpokenText = String(bit||""); lastSpokenTextNorm = normalize(lastSpokenText);

  const q = new URLSearchParams({
    text: bit,
    latency: String(params.latency),
    stability: String(params.stability),
    similarity: String(params.similarity),
    style: String(params.style)
  });

  return new Promise(async (resolve) => {
    try{
      ttsAudio = new Audio();
      ttsAudio.src = `/api/tts-stream?${q.toString()}`;
      ttsAudio.preload = "auto"; ttsAudio.crossOrigin = "anonymous";

      ttsCtx = new (window.AudioContext||window.webkitAudioContext)(); await ttsCtx.resume().catch(()=>{});
      const srcNode = ttsCtx.createMediaElementSource(ttsAudio);
      ttsGainNode = ttsCtx.createGain();
      ttsGainNode.gain.value = parseFloat(document.getElementById('volumeSlider').value) || TTS_BASE_GAIN;
      document.getElementById('volumeSlider').addEventListener('input', (e) => {
        if (ttsGainNode) ttsGainNode.gain.value = parseFloat(e.target.value);
      });
      ttsAnalyser = ttsCtx.createAnalyser(); ttsAnalyser.fftSize = 1024;
      srcNode.connect(ttsGainNode).connect(ttsAnalyser).connect(ttsCtx.destination);

      ttsAudio.onended = () => { abortBtn.style.display='none'; lastTTSEnd = Date.now(); resolve(); };
      ttsAudio.onerror = () => { abortBtn.style.display='none'; lastTTSEnd = Date.now(); resolve(); };

      await ttsAudio.play();
    }catch{
      abortBtn.style.display='none'; lastTTSEnd = Date.now(); resolve();
    }
  });
}

// --- ADD: Prefetch nästa bit som färdig MP3 (backend /api/tts) ---
async function prefetchBuffered(bit, params) {
  const res = await fetch('/api/tts', {
    method: 'POST',
    headers: { 'Content-Type':'application/json' },
    body: JSON.stringify({
      text: bit,
      // skicka vidare prosodi för konsekvens
      stability: params.stability, similarity: params.similarity, style: params.style, model: 'eleven_multilingual_v2'
    })
  });
  if (!res.ok) throw new Error('prefetch failed');
  const buf = await res.arrayBuffer();
  const blobUrl = URL.createObjectURL(new Blob([buf], { type: 'audio/mpeg' }));
  return blobUrl;
}

// --- ADD: Spela upp en redan buffrad bit ---
async function speakBufferedUrl(url) {
  stopTTS();
  state='SPEAKING'; setStatus(state,'Svarar…');
  abortBtn.style.display = 'inline-block';

  return new Promise(async (resolve) => {
    try{
      ttsAudio = new Audio();
      ttsAudio.src = url;
      ttsAudio.preload = "auto"; ttsAudio.crossOrigin = "anonymous";

      ttsCtx = new (window.AudioContext||window.webkitAudioContext)(); await ttsCtx.resume().catch(()=>{});
      const srcNode = ttsCtx.createMediaElementSource(ttsAudio);
      ttsGainNode = ttsCtx.createGain();
      ttsGainNode.gain.value = parseFloat(document.getElementById('volumeSlider').value) || TTS_BASE_GAIN;
      ttsAnalyser = ttsCtx.createAnalyser(); ttsAnalyser.fftSize = 1024;
      srcNode.connect(ttsGainNode).connect(ttsAnalyser).connect(ttsCtx.destination);

      ttsAudio.onended = () => { abortBtn.style.display='none'; lastTTSEnd = Date.now(); resolve(); };
      ttsAudio.onerror = () => { abortBtn.style.display='none'; lastTTSEnd = Date.now(); resolve(); };
      await ttsAudio.play();
    }catch{
      abortBtn.style.display='none'; lastTTSEnd = Date.now(); resolve();
    }
  });
}

// --- ADD: Huvudfunktion som kombinerar streaming + prefetch ---
async function playSpeechHybrid(fullText) {
  const bits = splitForTTS(fullText);
  if (!bits.length) return;

  // 1) Starta omedelbart med streaming av första biten
  const p0 = pickTTSParams(bits[0]);
  const nextPrefetch = (bits[1] ? prefetchBuffered(bits[1], pickTTSParams(bits[1])) : null);

  await speakStreamChunk(bits[0], p0);

  // 2) Spela resterande med “prefetch while playing”
  let i = 1;
  let nextUrl = nextPrefetch ? await nextPrefetch.catch(()=>null) : null;

  while (i < bits.length) {
    const thisBit = bits[i];
    const params = pickTTSParams(thisBit);

    // om vi inte hann prefetcha: gör det nu
    if (!nextUrl) nextUrl = await prefetchBuffered(thisBit, params).catch(()=>null);

    if (nextUrl) {
      // medan denna spelas, börja prefetch av nästa (i+1)
      const upcoming = (i+1 < bits.length) ? prefetchBuffered(bits[i+1], pickTTSParams(bits[i+1])) : null;
      await speakBufferedUrl(nextUrl);
      nextUrl = upcoming ? await upcoming.catch(()=>null) : null;
    } else {
      // fallback: streama
      await speakStreamChunk(thisBit, params);
    }
    i++;
  }
}

    function speak(text){
      return new Promise(async (resolve)=>{
        stopTTS(); state='SPEAKING'; setStatus(state,'Svarar… (säg "nästa" för fler steg)');
        abortBtn.style.display = 'inline-block';
        _speakResolve = resolve;
        lastSpokenText = String(text||"");
        lastSpokenTextNorm = normalize(lastSpokenText);
        try{
          const url = `/api/tts-stream?text=${encodeURIComponent(text)}&latency=3`;
          ttsAudio = new Audio(); ttsAudio.src = url; ttsAudio.preload = "auto"; ttsAudio.crossOrigin = "anonymous";
          ttsCtx = new (window.AudioContext||window.webkitAudioContext)(); await ttsCtx.resume().catch(()=>{});
          const srcNode = ttsCtx.createMediaElementSource(ttsAudio);
          ttsGainNode = ttsCtx.createGain(); ttsGainNode.gain.value = parseFloat(document.getElementById('volumeSlider').value) || TTS_BASE_GAIN;
          document.getElementById('volumeSlider').addEventListener('input', (e) => {
            if (ttsGainNode) ttsGainNode.gain.value = parseFloat(e.target.value);
          });
          ttsAnalyser = ttsCtx.createAnalyser(); ttsAnalyser.fftSize = 1024;
          srcNode.connect(ttsGainNode).connect(ttsAnalyser).connect(ttsCtx.destination);
          await ttsAudio.play();
          ttsAudio.onended = ()=>{
            abortBtn.style.display='none';
            lastTTSEnd = Date.now();
            _speakResolve && _speakResolve(); _speakResolve=null;
            if (running) setTimeout(()=>startListening(), LISTEN_DELAY_AFTER_TTS);
          };
          ttsAudio.onerror = ()=>{
            abortBtn.style.display='none';
            lastTTSEnd = Date.now();
            _speakResolve && _speakResolve(); _speakResolve=null;
            if (running) setTimeout(()=>startListening(), LISTEN_DELAY_AFTER_TTS);
          };
        }catch{
          abortBtn.style.display='none'; lastTTSEnd = Date.now();
          _speakResolve && _speakResolve(); _speakResolve=null;
          if (running) setTimeout(()=>startListening(), LISTEN_DELAY_AFTER_TTS);
        }
      });
    }

    // ---------- Steps reading ----------
    function resetSteps(steps){
      stepQueue = Array.isArray(steps) ? steps.slice() : [];
      stepOffset = 0;
    }
    async function speakStepsChunk(n = STEP_CHUNK_SIZE){
      if (!stepQueue.length) return;
      const chunk = stepQueue.splice(0, n);
      const text = chunk.map((s,i)=>`${stepOffset+i+1}. ${s}`).join('. ')
        + (stepQueue.length ? '. Säg "nästa" när du vill fortsätta.'
                            : '. Det var alla steg. Vill du ha förklaringen också?');
      stepOffset += chunk.length;
      await speak(text);
    }

    // ---------- Chat/UI ----------
    function renderDetails(cards, followUp){
      const srcNote = (Array.isArray(cards?.matched_headings) && cards.matched_headings.length)
        ? `<div class="src">Hämtat från: ${cards.matched_headings.join(', ')}</div>` : '';
      return `
        <div class="muted"><strong>Sammanfattning:</strong> ${cards?.summary||'—'}</div>
        ${cards?.steps?.length ? `<div class="muted"><strong>Steg:</strong><br>- ${cards.steps.join('<br>- ')}</div>` : ''}
        ${cards?.pitfalls?.length ? `<div class="muted"><strong>Fallgropar:</strong><br>- ${cards.pitfalls.join('<br>- ')}</div>` : ''}
        ${cards?.explanation ? `<details style="margin-top:.4rem"><summary class="link">Förklaring</summary><div class="muted" style="margin-top:.4rem">${cards.explanation}</div></details>` : ''}
        ${srcNote}
        ${followUp ? `<div style="margin-top:.4rem;opacity:.9"><em>${followUp}</em></div>` : ''}
      `;
    }

    async function askAssistant(text){
      state='THINKING'; setStatus(state,'Bearbetar…');
      try{
        const userId = localStorage.getItem('userId') || (()=>{ const x = 'u_' + Math.random().toString(36).slice(2); localStorage.setItem('userId', x); return x; })();
        const res = await fetch('/api/chat',{
          method:'POST', headers:{'Content-Type':'application/json','x-user-id':userId},
          body: JSON.stringify({ message:text, prev: { question: lastQ, assistant: lastA }, history: chatHistory, userId })
        });
        const data=await res.json(); if(!res.ok) throw new Error(data?.error || 'Chat-fel');

        let r=data.reply; if(typeof r==='string'){ try{ r=JSON.parse(r); }catch{} }
        r = r && typeof r==='object' ? r : { spoken: 'Okej.' };

        chatHistory.push({ user: text, assistant: r, ts: Date.now() });

        if (r.need?.clarify) {
          resetSteps([]);
          output.insertAdjacentHTML('beforeend', `<div class="pill">${r.need.question || r.spoken || 'Behöver lite mer info.'}</div>`);
          await speak(r.spoken || r.need.question || 'En sak till…');
          lastQ = text; lastA = r;
          return;
        }

        const bubble = document.createElement('div');
        bubble.className = 'pill';
        const uid = Date.now().toString();
        bubble.innerHTML = `<div>${r.spoken || 'Klart.'}</div>
                            <div style="margin-top:.5rem"><span class="link" id="toggle_${uid}">Visa detaljer</span></div>
                            <div id="details_${uid}" style="display:none;margin-top:.5rem">${renderDetails(r.cards||{}, r.follow_up||'')}</div>`;
        output.appendChild(bubble);

        const toggle = bubble.querySelector(`#toggle_${uid}`);
        const details = bubble.querySelector(`#details_${uid}`);
        toggle.addEventListener('click', ()=>{
          const open = details.style.display !== 'none';
          details.style.display = open ? 'none' : 'block';
          toggle.textContent = open ? 'Visa detaljer' : 'Dölj detaljer';
        });

        lastQ = text; lastA = r;

        // KRITISK FIX: Kolla om backend säger att bara läsa spoken
        const shouldSkipSteps = r.meta?.tts?.skip_steps || 
                               r.meta?.tts?.read_only_spoken || 
                               r.meta?.speech_source === "status_summary";
        
        const steps = Array.isArray(r.cards?.steps) ? r.cards.steps : [];
        resetSteps(steps);
        
        // Läs alltid spoken-delen först (hybrid TTS)
        await playSpeechHybrid(r.spoken || 'Okej.');
        
        // Läs steps ENDAST om backend inte säger att skippa dem
        if (steps.length && !shouldSkipSteps) {
          await speakStepsChunk();
        }

      }catch(err){
        output.insertAdjacentHTML('beforeend', `<div class="pill">Kunde inte få svar från AI. (${err?.message||'okänt fel'})</div>`);
        if(running) setTimeout(()=>startListening(), LISTEN_DELAY_AFTER_TTS);
      }
    }

    // ---------- Whisper ----------
    async function transcribe(blob){
      const fd = new FormData();
      fd.append('audio', blob, `audio.${REC_EXT}`);
      fd.append('mime', REC_MIME || 'audio/webm');
      const res=await fetch('/api/whisper',{ method:'POST', body: fd });
      const data=await res.json(); if(!res.ok) throw new Error(data?.error || 'Transkriberingsfel');
      return (data.text||'').trim();
    }

    // ---------- VAD ----------
    function calibrateThreshold(){
      return new Promise(async (resolve)=>{
        const t0 = performance.now();
        let acc=0, n=0;
        while (performance.now()-t0 < 500){
          analyser.getByteTimeDomainData(micArr);
          const lvl = rmsLevel(micArr);
          acc += lvl; n++;
          await new Promise(r=>setTimeout(r, 20));
        }
        const baseline = Math.round(acc/Math.max(1,n));
        resolve(Math.max(4, Math.min(20, baseline + 1)));
      });
    }

    // ---------- LISTEN ----------
    async function startListening(){
      if(!running) return;
      state='LISTENING'; setStatus(state,'Lyssnar… (bli tyst för att skicka)');

      chunks=[]; const startedAt=performance.now();
      let silentMs=0, talkMs=0;
      const speechThreshold = await calibrateThreshold();

      try{
        mediaRecorder = new MediaRecorder(micStream, REC_MIME ? { mimeType: REC_MIME, audioBitsPerSecond: 128000 } : undefined);
      }catch{ mediaRecorder = new MediaRecorder(micStream); }

      mediaRecorder.ondataavailable = (e)=>{ if(e.data.size>0) chunks.push(e.data); };
      mediaRecorder.onstop = async ()=>{
        const type = REC_MIME || (chunks[0]?.type || 'audio/webm');
        const blob = new Blob(chunks, { type });

        const withinEcho = (Date.now() - lastTTSEnd) < ECHO_SUPPRESS_MS;
        const minSpeech = withinEcho ? MIN_SPEECH_MS_ECHO : MIN_SPEECH_MS;

        const elapsed = performance.now()-startedAt;
        const acceptByMs = (talkMs >= minSpeech);
        const acceptByDuty = (talkMs / Math.max(1, elapsed)) >= (withinEcho ? MIN_DUTY_ECHO : MIN_DUTY);
        const accept = acceptByMs && acceptByDuty;

        if (!accept || blob.size < MIN_BLOB_BYTES) { if(running) startListening(); return; }

        try{
          const text = await transcribe(blob);
          if (!text || HALLU.test(text) || likelyEchoOfTTS(text)) { if(running) startListening(); return; }

          // NYTT: kastar bort falsk-väckningar och korta fillers
          if (shouldDropUtterance(text, talkMs, elapsed)) { if(running) startListening(); return; }

          const t = text.toLowerCase();
          if (stepQueue.length && STEP_COMMANDS.test(t) && !likelyEchoOfTTS(text)) {
            await speakStepsChunk(); return;
          }

          output.insertAdjacentHTML('beforeend', `<div class="pill"><strong>Du sa:</strong> ${text}</div>`);
          await askAssistant(text);
        }catch{
          output.insertAdjacentHTML('beforeend',"<div class='pill'>Kunde inte transkribera ljudet.</div>");
          if(running) startListening();
        }
      };
      mediaRecorder.start();

      const vadTimer=setInterval(()=>{
        if (!running || !mediaRecorder || mediaRecorder.state==='inactive'){ clearInterval(vadTimer); return; }
        analyser.getByteTimeDomainData(micArr);
        const lvl = rmsLevel(micArr);
        if (lvl >= speechThreshold) { talkMs += 100; silentMs = 0; }
        else { silentMs += 100; }
        const elapsed = performance.now()-startedAt;
        if (silentMs >= SILENCE_HOLD_MS || elapsed > MAX_RECORD_MS){
          clearInterval(vadTimer);
          try{ mediaRecorder.state!=='inactive' && mediaRecorder.stop(); }catch{}
        }
      },100);
    }

    // ---------- START/STOP ----------
    async function getMicStream(){
      const constraints = { audio: { echoCancellation:true, noiseSuppression:true, autoGainControl:false } };
      REC_MIME = MIME_CANDIDATES.find(m => !m || MediaRecorder.isTypeSupported(m)) || '';
      REC_EXT  = REC_MIME.includes('mp4') ? 'm4a' : REC_MIME.includes('ogg') ? 'ogg' : 'webm';

      micStream = await navigator.mediaDevices.getUserMedia(constraints);
      audioCtxVAD = new (window.AudioContext||window.webkitAudioContext)();
      await audioCtxVAD.resume().catch(()=>{});
      const src = audioCtxVAD.createMediaStreamSource(micStream);
      analyser = audioCtxVAD.createAnalyser(); analyser.fftSize = 2048; analyser.smoothingTimeConstant = 0.6;
      micArr = new Uint8Array(analyser.fftSize); src.connect(analyser);
      if(!rafId) rafId = requestAnimationFrame(loop);
    }
function enterImmersive(){ document.body.classList.add('immersive'); }
function exitImmersive(){ document.body.classList.remove('immersive'); setHudSpeech(''); }
function setHudSpeech(t){
  const el = document.getElementById('speechSub');
  if (!el) return;
  const txt = String(t||'').trim();
  el.textContent = txt;
  el.classList.toggle('visible', !!txt);
}

    // CHANGED: startLoop spelar hälsning först (i samma user-gesture), sedan startar lyssning
    async function startLoop(){
  if (running) return; 
  running = true;

  state = 'THINKING';
  setStatus(state,'Startar…');
  startBtn.style.display = 'none';
  stopBtn.style.display  = 'inline-block';

  try {
    // 0) Jarvis power-on: visuellt + chime
    document.body.classList.add('awake');
    if (typeof triggerBootFX === 'function') triggerBootFX();
    if (typeof playPowerOnChime === 'function') await playPowerOnChime();

    // 1) “Unlocka” ljud enligt autoplay-policy
    try {
      const tmp = new (window.AudioContext || window.webkitAudioContext)();
      await tmp.resume().catch(()=>{});
      try { await tmp.close(); } catch {}
    } catch {}

    // 2) Spela Jarvis-hälsning EN gång innan vi börjar lyssna
    if (!hasGreeted && typeof playWelcomeGreeting === 'function') {
      try {
        await playWelcomeGreeting();
        hasGreeted = true;
      } catch (e) {
        console.warn('Greeting failed:', e);
      }
    }

    // 3) Initiera mic/visualizer och börja lyssna efter en kort paus
    await getMicStream();
    setStatus('LISTENING','Lyssnar… (bli tyst för att skicka)');
    setTimeout(() => startListening(), 300);

  } catch {
    output.insertAdjacentHTML('beforeend', "<div class='pill'>Mikrofon kunde inte startas (behörighet eller HTTPS?).</div>");
    running = false; 
    startBtn.style.display = 'inline-block'; 
    stopBtn.style.display='none';
    document.body.classList.remove('awake'); // reset om boot misslyckas
  }
}


    function stopLoop(){
      running=false; state='IDLE'; setStatus(state,'Stoppad');
      startBtn.style.display='inline-block'; stopBtn.style.display='none';
      abortBtn.style.display='none';
      if(rafId){ cancelAnimationFrame(rafId); rafId=null; }
      try{ mediaRecorder && mediaRecorder.state!=='inactive' && mediaRecorder.stop(); }catch{}
      try{ analyser && analyser.disconnect(); }catch{}
      try{ audioCtxVAD && audioCtxVAD.close(); }catch{}
      analyser=null; audioCtxVAD=null; micArr=null;
      stepQueue=[]; stepOffset=0; lastQ=null; lastA=null;
      chatHistory = [];
      try{ if(micStream){ micStream.getTracks().forEach(t=>t.stop()); micStream=null; } }catch{}
      try{ if(ttsAudio){ ttsAudio.pause(); } }catch{}
      STEP_CHUNK_SIZE = 4;
    }

    window.addEventListener('keydown',(e)=>{ if(e.key===' ' && state==='SPEAKING'){ e.preventDefault(); stopTTS(); abortBtn.style.display='none'; setTimeout(()=>startListening(), LISTEN_DELAY_AFTER_TTS); }});
    window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') stopLoop(); });

    startBtn.addEventListener('click', startLoop);
    stopBtn.addEventListener('click', stopLoop);
    abortBtn.addEventListener('click', ()=>{ if (state==='SPEAKING'){ stopTTS(); abortBtn.style.display='none'; setTimeout(()=>startListening(), LISTEN_DELAY_AFTER_TTS); }});

    // Debug: text till chat (oförändrat – inget filter här)
    debugBtn.addEventListener('click', async () => {
      const text = debugInput.value.trim();
      if (text) {
        output.insertAdjacentHTML('beforeend', `<div class="pill"><strong>Du skrev (debug):</strong> ${text}</div>`);
        await askAssistant(text);
        debugInput.value = '';
      }
    });

    // ADD: Enter-tangent för debug input
    debugInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        debugBtn.click();
      }
    });

    // MODIFY: Byt från mellanslag till Escape för att avbryta TTS
    window.addEventListener('keydown',(e)=>{ 
      if(e.key==='Escape' && state==='SPEAKING'){ 
        e.preventDefault(); 
        stopTTS(); 
        abortBtn.style.display='none'; 
        setTimeout(()=>startListening(), LISTEN_DELAY_AFTER_TTS); 
      }
    });

    // Ta bort den gamla mellanslag-hanteraren
    // window.addEventListener('keydown',(e)=>{ 
    //   if(e.key===' ' && state==='SPEAKING' && document.activeElement !== debugInput){ 
    //     e.preventDefault(); 
    //     stopTTS(); 
    //     abortBtn.style.display='none'; 
    //     setTimeout(()=>startListening(), LISTEN_DELAY_AFTER_TTS); 
    //   }
    // });

    // --- likelyEchoOfTTS (behåller din tidigare)
    function likelyEchoOfTTS(text){
      const within = Date.now() - lastTTSEnd < ECHO_SUPPRESS_MS;
      if (!within) return false;
      const t = normalize(text);
      if (!t) return true;
      if (!lastSpokenTextNorm) return false;
      if (lastSpokenTextNorm.includes(t)) return true;
      const ts = t.split(" ").filter(w=>w.length>=3);
      if (!ts.length) return true;
      const ls = new Set(lastSpokenTextNorm.split(" ").filter(w=>w.length>=3));
      let overlap=0;
      ts.forEach(w=>{ if(ls.has(w)) overlap++; });
      return (overlap / ts.length) >= 0.7;
    }

    const reportBtn = document.getElementById('reportBtn');
    reportBtn.addEventListener('click', () => {
      // Se till att userId finns innan vi lämnar sidan (report.html läser från localStorage)
      const uid = localStorage.getItem('userId') || (() => {
        const x = 'u_' + Math.random().toString(36).slice(2);
        localStorage.setItem('userId', x);
        return x;
      })();

      // Avsluta loop/tts snyggt innan vi navigerar
      try { stopTTS(); } catch {}
      try { stopLoop(); } catch {}

      // Navigera till rapport-sidan (skickar även med uid som query om du vill använda den där)
      const target = new URL('https://coach-assistant.vercel.app/report.html', location.href);
      target.searchParams.set('from', 'voice');
      target.searchParams.set('uid', uid);
      location.href = target.toString();
    });

    // --- GPT-driven välkomsthälsning (kallas från startLoop)
    async function playWelcomeGreeting() {
      try {
        const res = await fetch('/api/greeting');
        const { text } = await res.json();

        if (typeof playSpeechHybrid === 'function') {
          await playSpeechHybrid(text);
        } else {
          await speak(text);
        }
      } catch (e) {
        console.warn("Greeting failed:", e);
      }
    }

    // Inga auto-startar pga autoplay-policy; hälsning triggas i startLoop
    let hasGreeted = false;
// Minimal chime som spelas av klicket (lagligt enligt autoplay-policy)
async function playPowerOnChime() {
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  await ctx.resume();
  const o1 = ctx.createOscillator();
  const g  = ctx.createGain();
  o1.type = 'sine';
  o1.frequency.setValueAtTime(440, ctx.currentTime);
  o1.frequency.exponentialRampToValueAtTime(880, ctx.currentTime + 0.18);
  g.gain.setValueAtTime(0.001, ctx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.05, ctx.currentTime + 0.02);
  g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.28);
  o1.connect(g).connect(ctx.destination);
  o1.start();
  o1.stop(ctx.currentTime + 0.30);
  // stäng efter en stund för att frigöra
  setTimeout(()=>ctx.close().catch(()=>{}), 500);
}

function triggerBootFX() {
  const fx = document.getElementById('bootFx');
  if (!fx) return;
  fx.classList.add('active');
  // retrigger animation
  fx.classList.remove('flash'); void fx.offsetWidth; fx.classList.add('flash');
  // auto-hide overlay efter 1.2s
  setTimeout(()=> fx.classList.remove('active'), 1200);
}

  </script>

</body>
</html>
