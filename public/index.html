<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Coach Assistant ‚Äì Linje 65 (Realtime)</title>
  <style>
    :root {
      --bg: #0b0f14;
      --panel: #121821;
      --text: #e6edf3;
      --muted: #9fb0c3;
      --accent: #5eead4;
      --danger: #f87171;
      --ok: #86efac;
      --pill: #182232;
    }
    html, body { height: 100%; }
    body {
      margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Noto Sans", "Helvetica Neue", Arial;
      background: radial-gradient(1200px 600px at 20% 0%, #0e1621, #0b0f14 75%);
      color: var(--text);
    }
    .wrap { max-width: 980px; margin: 0 auto; padding: 24px; }
    header { display:flex; align-items:center; justify-content:space-between; gap:16px; margin-bottom: 16px; }
    header .title { font-size: 20px; font-weight: 700; letter-spacing: .3px; }
    .controls { display:flex; flex-wrap: wrap; gap:8px; align-items:center; }
    button { appearance:none; border: none; padding: 10px 14px; border-radius: 12px; cursor:pointer; font-weight: 600; }
    .primary { background: var(--accent); color:#0a0f14; }
    .ghost { background: #0d1520; color: var(--text); border: 1px solid #233146; }
    .danger { background: var(--danger); color: #111; }
    .muted { color: var(--muted); font-size: 13px; }
    .row { display:flex; gap:10px; align-items:center; }
    input[type="text"], input[type="search"] { background:#0d1622; color:var(--text); border:1px solid #243244; border-radius:10px; padding:10px 12px; }
    .pill { background: var(--pill); color: var(--text); padding: 8px 12px; border-radius: 999px; display:inline-block; margin: 6px 6px 0 0; font-size: 12px; border:1px solid #26364a; }
    .panel { background: var(--panel); border: 1px solid #233146; border-radius: 16px; padding: 14px; }
    #output { display:flex; flex-direction: column; gap: 10px; margin-top: 14px; }
    .bubble { background:#0f1722; border:1px solid #213145; border-radius:16px; padding:12px 14px; white-space: pre-wrap; line-height: 1.45; }
    .bubble.user { background:#0f1a27; border-color:#24415a; }
    .bubble.assistant { background:#0f1823; border-color:#2c3f57; }
    .bubble.error { background:#1b0f12; border-color:#4a1f2a; }
    .tag { font-size: 11px; opacity:.8; }
    .status { margin-left: 8px; }
    .vis { height: 10px; background: #0e1420; border-radius: 9999px; overflow: hidden; border:1px solid #213145; }
    .vis > b { display:block; height:100%; width: 6%; background: linear-gradient(90deg,#85f3d5,#4dd4ff); transition: width .08s linear; }
    footer { margin-top: 24px; color: var(--muted); font-size: 12px; }
    .src { font-size:12px; margin-top:6px; color:#bfd7ff; opacity:.9; }
    .flex { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">ü¶æ Coach Assistant ‚Äì Linje 65 (Realtime)</div>
      <div class="controls">
        <div class="row">
          <label class="muted" for="operatorId">Operat√∂r:</label>
          <input id="operatorId" type="text" placeholder="t.ex. kevin" style="width:140px" />
          <button class="ghost" id="saveIdBtn">Spara</button>
        </div>
        <button class="primary" id="rtBtn">Anslut Realtime</button>
        <button class="ghost" id="rtHangup" style="display:none">L√§gg p√•</button>
      </div>
    </header>

    <div class="panel">
      <div class="flex">
        <div id="rtStatus" class="pill">Inte ansluten</div>
        <div id="memStatus" class="pill">Minne: ‚Äî</div>
        <div class="vis" style="flex:1 1 220px; min-width:220px"><b id="micBar"></b></div>
      </div>

      <div class="row" style="margin-top:10px">
        <input id="quickText" type="search" placeholder="Skicka text till assistenten (enter)" style="flex:1" />
        <button class="ghost" id="sendTextBtn">Skicka</button>
      </div>

      <!-- Manuell fels√∂kning av RAG utan Realtime -->
      <div class="row" style="margin-top:10px">
        <input id="manualQuery" type="search" placeholder="Testa manual-s√∂k (t.ex. 'sortbyte i tappen')" style="flex:1" />
        <button class="ghost" id="manualBtn">Testa manual</button>
      </div>

      <div id="output"></div>
    </div>

    <footer>
      Realtime-r√∂st med WebRTC. Manual/RAG via Supabase. Logg + minne i Supabase (conversations/messages/summary).<br>
      <span class="muted">Tips: s√§g "Spara detta" s√• kan assistenten l√§gga i l√•ngtidsminne via save_memory.</span>
    </footer>
  </div>

  <script>
    // ========= UI helpers =========
    const $ = sel => document.querySelector(sel);
    const $$ = sel => Array.from(document.querySelectorAll(sel));

    // ========= Robust fetch -> JSON (f√∂r att slippa "Unexpected token ‚Ä¶") =========
    async function fetchJSON(url, opts) {
      const r = await fetch(url, opts);
      const text = await r.text();
      let json;
      try { json = JSON.parse(text); }
      catch { throw new Error(`${r.status} ${r.statusText}: ${text.slice(0,200)}`); }
      if (!r.ok || json?.ok === false) throw new Error(json?.error || json?.message || `${r.status} ${r.statusText}`);
      return json;
    }

    function pill(text) { const d = document.createElement('div'); d.className = 'pill'; d.textContent = text; return d; }
    function bubble(text, role='assistant') {
      const d = document.createElement('div'); d.className = 'bubble ' + role; d.textContent = text; return d;
    }
    function errorBubble(text) {
      const d = document.createElement('div'); d.className = 'bubble error'; d.textContent = text; return d;
    }
    function append(el) { $('#output').appendChild(el); el.scrollIntoView({behavior:'smooth', block:'end'}); }

    // ========= Operator ID persistence =========
    const operatorInput = $('#operatorId');
    operatorInput.value = localStorage.getItem('operator_id') || 'kevin';
    $('#saveIdBtn').onclick = () => {
      localStorage.setItem('operator_id', operatorInput.value.trim() || 'kevin');
      append(pill('Operat√∂r sparad: ' + (localStorage.getItem('operator_id'))));
    };

    // ========= Realtime state =========
    let rt = { pc:null, dc:null, mic:null, remoteAudio:null, connected:false, conversation_id:null, _msgCount:0 };
    const toolCalls = new Map(); // tool_call_id -> { name, argsText }

    // mic visualizer (simple)
    let micAnalyser, micData;
    function setupMicViz(stream) {
      try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const src = ctx.createMediaStreamSource(stream);
        micAnalyser = ctx.createAnalyser();
        micAnalyser.fftSize = 512; micAnalyser.smoothingTimeConstant = 0.8;
        src.connect(micAnalyser);
        micData = new Uint8Array(micAnalyser.frequencyBinCount);
        const bar = $('#micBar');
        (function loop(){
          if (!micAnalyser) return; micAnalyser.getByteTimeDomainData(micData);
          // peak amplitude 0..1
          let peak = 0; for (let i=0;i<micData.length;i++){ const v = Math.abs(micData[i]-128)/128; if (v>peak) peak=v; }
          bar.style.width = Math.min(98, (peak*100*1.6)+6) + '%';
          requestAnimationFrame(loop);
        })();
      } catch(e) {}
    }

    // ========= Logging to Supabase via server =========
    async function logMsg(role, content, modality='voice', payload=null) {
      if (!rt.conversation_id) return;
      try {
        await fetch('/api/memory-log', {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ conversation_id: rt.conversation_id, role, content, modality, payload })
        });
        rt._msgCount = (rt._msgCount || 0) + 1;
        if (rt._msgCount % 8 === 0) {
          fetch('/api/memory-summarize', {
            method: 'POST', headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ conversation_id: rt.conversation_id })
          }).then(()=> $('#memStatus').textContent = 'Minne: uppdaterat');
        }
      } catch {}
    }

    // ========= Realtime connect =========
    $('#rtBtn').addEventListener('click', connectRealtime);
    $('#rtHangup').addEventListener('click', hangupRealtime);

    async function connectRealtime() {
      const status = t => $('#rtStatus').textContent = t;
      try {
        // 0) Mic
        rt.mic = await navigator.mediaDevices.getUserMedia({ audio: true });
        setupMicViz(rt.mic);

        // 1) Init/restore conversation & memory
        const memInit = await fetchJSON('/api/memory-init', {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ userId: localStorage.getItem('operator_id') || 'kevin' })
        });
        const conversation_id = memInit.conversation_id;
        const memoryBootstrap = memInit.memoryBootstrap || '';
        rt.conversation_id = conversation_id;
        $('#memStatus').textContent = 'Minne: laddat';

        // 2) RTCPeerConnection
        rt.pc = new RTCPeerConnection();
        rt.mic.getTracks().forEach(t => rt.pc.addTrack(t, rt.mic));

        // 3) Spela modellens ljud
        rt.remoteAudio = new Audio(); rt.remoteAudio.autoplay = true; rt.remoteAudio.playsInline = true; rt.remoteAudio.muted = false;
        rt.pc.ontrack = (e) => { rt.remoteAudio.srcObject = e.streams[0]; };

        // 4) Data channel
        rt.dc = rt.pc.createDataChannel('oai-events');
        rt.dc.onopen = () => {
          // Skicka session settings inkl. minnesinjektion och tools
          const sessUpdate = {
            type: 'session.update',
            session: {
              instructions: `Du √§r Coach Assistant f√∂r Linje 65.\nSvara kort och stegvis p√• svenska. Om manualen saknar t√§ckning: s√§g det tydligt och f√∂resl√• n√§sta trygga steg.\n\n[Minne & senaste v√§xlingar]\n${memoryBootstrap}`,
              turn_detection: { type: 'server_vad' },
              tools: [
                {
                  type: 'function',
                  name: 'search_manual',
                  description: 'S√∂k i Linje65-manualdatabasen och returnera tr√§ffar med k√§llor.',
                  parameters: {
                    type: 'object',
                    properties: {
                      query: { type: 'string' },
                      k: { type: 'integer', default: 6 },
                      minSim: { type: 'number', default: 0.6 }
                    },
                    required: ['query']
                  }
                },
                {
                  type: 'function',
                  name: 'save_memory',
                  description: 'Spara stabil fakta/inst√§llning i anv√§ndarens l√•ngtidsminne.',
                  parameters: {
                    type: 'object',
                    properties: { key: { type: 'string' }, value: { type: 'string' } },
                    required: ['key','value']
                  }
                }
              ]
            }
          };
          rt.dc.send(JSON.stringify(sessUpdate));
          append(pill('Realtime ansluten. Prata n√§r som helst.'));
        };

        rt.dc.onmessage = (e) => {
          try { handleRealtimeMessage(JSON.parse(e.data)); } catch(err) { /* non-json events ignored */ }
        };

        // 5) Token + offer/answer
        const { token, model } = await fetchJSON('/api/rt-token');
        const offer = await rt.pc.createOffer();
        await rt.pc.setLocalDescription(offer);
        const sdpAnswer = await fetch(`https://api.openai.com/v1/realtime?model=${encodeURIComponent(model)}`, {
          method: 'POST', headers: { Authorization: `Bearer ${token}`, 'Content-Type': 'application/sdp' }, body: offer.sdp
        }).then(r => r.text());
        await rt.pc.setRemoteDescription({ type: 'answer', sdp: sdpAnswer });

        // 6) UI state
        rt.connected = true;
        $('#rtBtn').style.display = 'none';
        $('#rtHangup').style.display = 'inline-block';
        status('Realtime ansluten');
      } catch (e) {
        console.error(e);
        $('#rtStatus').textContent = `Realtime misslyckades: ${e?.message || e}`;
        append(errorBubble('Fel vid anslutning: ' + (e?.message || e)));
      }
    }

    async function hangupRealtime() {
      try {
        rt.dc?.close();
        rt.pc?.getSenders()?.forEach(s => s.track?.stop());
        rt.pc?.close();
        rt.mic?.getTracks()?.forEach(t => t.stop());
        micAnalyser = null;
      } catch {}
      rt = { pc:null, dc:null, mic:null, remoteAudio:null, connected:false, conversation_id:rt.conversation_id, _msgCount:rt._msgCount };
      $('#rtBtn').style.display = 'inline-block';
      $('#rtHangup').style.display = 'none';
      $('#rtStatus').textContent = 'Inte ansluten';
      append(pill('Samtal avslutat.'));
    }

    // ========= Realtime event handler =========
    function handleRealtimeMessage(msg) {
      // 0) Tool arg deltas
      if (msg.type === 'response.function_call_arguments.delta') {
        const id = msg.id || msg.tool_call_id || msg.response_id || 'unknown';
        const prev = toolCalls.get(id) || { name: msg.name, argsText: '' };
        prev.argsText += (msg.delta || msg.arguments_delta || '');
        prev.name = prev.name || msg.name; toolCalls.set(id, prev);
        return;
      }

      // 1) Tool call completed ‚Üí execute tool
      if (msg.type === 'response.function_call.completed') {
        const id = msg.id || msg.tool_call_id || 'unknown';
        const tc = toolCalls.get(id);
        if (!tc) return;
        if (tc.name === 'search_manual') return runToolSearchManual(tc);
        if (tc.name === 'save_memory') return runToolSaveMemory(tc);
        return;
      }

      // 2) User transcript (final)
      if (msg.type && /input.*transcript\.done/.test(msg.type)) {
        const text = msg.transcript || msg.text || '';
        if (text?.trim()) {
          append(bubble(text, 'user'));
          logMsg('user', text, 'voice', msg);
        }
        return;
      }

      // 3) Assistant final text
      if (msg.type === 'response.output_text.done') {
        const text = msg.output_text || msg.text || '';
        if (text?.trim()) {
          append(bubble(text, 'assistant'));
          logMsg('assistant', text, 'voice', msg);
          // Visa k√§llor om de n√§mns
          const idx = text.indexOf('H√§mtat fr√•n:');
          if (idx !== -1) {
            const list = text.slice(idx + 'H√§mtat fr√•n:'.length).trim();
            append(pill('H√§mtat fr√•n:')); const d = document.createElement('div'); d.className='src'; d.innerHTML = list.replaceAll('\n','<br>'); append(d);
          }
        }
        return;
      }
    }

    // ========= Tools =========
    function parseArgsSafe(s) { try { return JSON.parse(s || '{}'); } catch { return {}; } }

    async function runToolSearchManual(tc) {
      const args = parseArgsSafe(tc.argsText);
      const body = { query: args.query, topK: args.k, minSim: args.minSim };
      try {
        const data = await fetchJSON('/api/search-manual', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });
        const sourcesList = (data.snippets || []).map((s,i) =>
          `[#${i+1} | ${s.title || 'manual'} ‚Ä¢ idx:${s.idx} ‚Ä¢ score:${(s.score??0).toFixed(2)}]`
        ).join('\n');
        const toolText = `TOOL_OUTPUT_START\n${data.context || 'INGEN_TR√ÑFF'}\nTOOL_OUTPUT_SOURCES\n${sourcesList || 'inga k√§llor'}\nTOOL_OUTPUT_END`;
        // √Öterkoppla till modellen som nytt svar
        rt.dc?.send(JSON.stringify({
          type: 'response.create',
          response: {
            modalities: ['audio','text'],
            instructions: `Svara ENBART baserat p√• TOOL_OUTPUT nedan. Om 'INGEN_TR√ÑFF' f√∂rekommer: s√§g att du saknar s√§kra uppgifter.\nAvsluta med "H√§mtat fr√•n:" f√∂ljt av raderna under TOOL_OUTPUT_SOURCES.\nTOOL_OUTPUT:\n${toolText}`
          }
        }));
      } catch (err) {
        console.error('search-manual error', err);
        rt.dc?.send(JSON.stringify({ type: 'response.create', response: { modalities:['audio','text'], instructions: 'Kunde inte n√• manual-s√∂k. S√§g detta kort och f√∂resl√• att f√∂rs√∂ka igen.' } }));
      }
    }

    async function runToolSaveMemory(tc) {
      const args = parseArgsSafe(tc.argsText);
      try {
        await fetch('/api/save-memory', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ userId: localStorage.getItem('operator_id') || 'kevin', key: args.key, value: args.value })
        });
        rt.dc?.send(JSON.stringify({ type:'response.create', response:{ modalities:['audio','text'], instructions:`Noterat. Jag sparade minnet: ${args.key} = ${args.value}.` } }));
      } catch (e) {
        rt.dc?.send(JSON.stringify({ type:'response.create', response:{ modalities:['audio','text'], instructions:`Jag kunde inte spara minnet just nu.` } }));
      }
    }

    // ========= Send text manually =========
    $('#sendTextBtn').onclick = sendQuickText;
    $('#quickText').addEventListener('keydown', e => { if (e.key==='Enter') sendQuickText(); });
    function sendQuickText(){
      const t = $('#quickText').value.trim(); if (!t) return;
      $('#quickText').value=''; sendTextToRealtime(t); append(bubble('‚û§ ' + t, 'user'));
    }
    function sendTextToRealtime(text) {
      if (!rt?.dc || rt.dc.readyState !== 'open') { append(pill('Inte ansluten.')); return; }
      rt.dc.send(JSON.stringify({ type: 'input_text', text }));
      rt.dc.send(JSON.stringify({ type: 'response.create', response: { modalities: ['audio','text'] } }));
    }

    // ========= Manual-test UI (direkt mot /api/search-manual) =========
    $('#manualBtn').addEventListener('click', testManualSearch);
    $('#manualQuery').addEventListener('keydown', e => { if (e.key==='Enter') testManualSearch(); });
    async function testManualSearch() {
      const q = $('#manualQuery').value.trim();
      if (!q) { append(pill('Skriv en fr√•ga f√∂r manualen.')); return; }
      append(bubble('üîé Manual: ' + q, 'user'));
      try {
        const data = await fetchJSON('/api/search-manual', {
          method:'POST', headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ query: q })
        });
        if (!data.count) {
          append(bubble('Inga tr√§ffar i manualen.', 'assistant'));
          return;
        }
        const lines = data.snippets.map((s,i)=> `#${i+1} ‚Ä¢ ${s.title || 'manual'} ‚Ä¢ idx:${s.idx} ‚Ä¢ score:${(s.score??0).toFixed(2)}\n${s.text}`).join('\n---\n');
        append(bubble(lines, 'assistant'));
      } catch (e) {
        append(errorBubble('Manual-s√∂k fel: ' + e.message));
      }
    }
  </script>
</body>
</html>
