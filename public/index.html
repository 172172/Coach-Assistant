<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Coach Assistant – Linje 65 (Realtime)</title>
  <style>
    :root{--bg:#0b0f14;--panel:#121821;--text:#e6edf3;--muted:#9fb0c3;--accent:#5eead4;--danger:#f87171;--ok:#86efac;--pill:#182232}
    html,body{height:100%}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Noto Sans","Helvetica Neue",Arial;background:radial-gradient(1200px 600px at 20% 0%,#0e1621,#0b0f14 75%);color:var(--text)}
    .wrap{max-width:980px;margin:0 auto;padding:24px}
    header{display:flex;align-items:center;justify-content:space-between;gap:16px;margin-bottom:16px}
    header .title{font-size:20px;font-weight:700;letter-spacing:.3px}
    .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    button{appearance:none;border:none;padding:10px 14px;border-radius:12px;cursor:pointer;font-weight:600}
    .primary{background:var(--accent);color:#0a0f14}
    .ghost{background:#0d1520;color:var(--text);border:1px solid #233146}
    .danger{background:var(--danger);color:#111}
    .muted{color:var(--muted);font-size:13px}
    .row{display:flex;gap:10px;align-items:center}
    input[type="text"],input[type="search"]{background:#0d1622;color:var(--text);border:1px solid #243244;border-radius:10px;padding:10px 12px}
    .pill{background:var(--pill);color:var(--text);padding:8px 12px;border-radius:999px;display:inline-block;margin:6px 6px 0 0;font-size:12px;border:1px solid #26364a}
    .panel{background:var(--panel);border:1px solid #233146;border-radius:16px;padding:14px}
    #output{display:flex;flex-direction:column;gap:10px;margin-top:14px}
    .bubble{background:#0f1722;border:1px solid #213145;border-radius:16px;padding:12px 14px;white-space:pre-wrap;line-height:1.45}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">Coach Assistant – Linje 65</div>
      <div class="controls">
        <button id="rtBtn" class="primary">Starta röst</button>
        <button id="rtHangup" class="danger" style="display:none">Avsluta</button>
        <span id="rtStatus" class="muted">Inte ansluten</span>
        <span id="memStatus" class="muted">Minne…</span>
      </div>
    </header>

    <div class="panel">
      <div class="row" style="margin-bottom:8px">
        <input id="quickText" type="text" placeholder="Skriv fråga…" style="flex:1" />
        <button id="sendTextBtn" class="ghost">Skicka</button>
      </div>
      <div class="row">
        <input id="manualQuery" type="text" placeholder="Testa manual-sök…" style="flex:1" />
        <button id="manualBtn" class="ghost">Manual</button>
      </div>
    </div>

    <div id="output"></div>
  </div>

  <script>
/* ======= Realtime + RAG integrerad ======= */
const $ = s => document.querySelector(s);
async function fetchJSON(url, opts){
  const r=await fetch(url,opts); const t=await r.text();
  let j; try{ j=JSON.parse(t); }catch{ throw new Error(`${r.status} ${r.statusText}: ${t.slice(0,180)}`); }
  if(!r.ok || j?.ok===false) throw new Error(j?.error||j?.message||`${r.status} ${r.statusText}`);
  return j;
}
const pill = t => { const d=document.createElement('div'); d.className='pill'; d.textContent=t; return d; };
const bubble = (t,role='assistant') => { const d=document.createElement('div'); d.className='bubble '+role; d.textContent=t; return d; };
const errorBubble = t => { const d=document.createElement('div'); d.className='bubble error'; d.textContent=t; return d; };
const append = el => { $('#output').appendChild(el); el.scrollIntoView({behavior:'smooth',block:'end'}); };

let operatorId = localStorage.getItem('operator_id') || 'kevin';

let rt = {
  pc:null, dc:null, mic:null, remoteAudio:null, connected:false,
  conversation_id:null, _msgCount:0,
  _ragBusy:false, _lastQuery:"", _lastToolCallId:null,
  cancelAutos:false, skipCancelForNextCreate:false, allowedResponseIds:new Set(),
  _lastUserText:"", _liveUserBuf:"",
  _pendingTool:null, _fallbackTimer:null
};
const toolCalls = new Map();
const RAG_TIMEOUT_MS = 8000;
const WAIT_FOR_QUERY_MS = 1200;
let ragTimer = null;

function setupMicViz(stream){
  try{
    const ctx=new (window.AudioContext||window.webkitAudioContext)();
    const src=ctx.createMediaStreamSource(stream);
    const analyser=ctx.createAnalyser(); analyser.fftSize=256;
    src.connect(analyser);
  }catch{}
}

async function logMsg(role, content, modality='voice', payload=null){
  if(!rt.conversation_id) return;
  try{
    await fetch('/api/memory-log',{
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body:JSON.stringify({conversation_id:rt.conversation_id,role,content,modality,payload})
    });
    rt._msgCount=(rt._msgCount||0)+1;
  }catch{}
}

document.getElementById('rtBtn').addEventListener('click', connectRealtime);
document.getElementById('rtHangup').addEventListener('click', hangupRealtime);

async function connectRealtime(){
  const status=t=>$('#rtStatus').textContent=t;
  try{
    rt.mic = await navigator.mediaDevices.getUserMedia({audio:true});
    setupMicViz(rt.mic);

    const memInit=await fetchJSON('/api/memory-init',{
      method:'POST',headers:{'Content-Type':'application/json'},
      body:JSON.stringify({userId:operatorId})
    });
    rt.conversation_id = memInit.conversation_id;
    $('#memStatus').textContent='Minne: laddat';

    rt.pc = new RTCPeerConnection();
    rt.pc.addTransceiver('audio',{direction:'recvonly'});
    rt.mic.getTracks().forEach(t=>rt.pc.addTrack(t,rt.mic));
    rt.remoteAudio=new Audio(); rt.remoteAudio.autoplay=true; rt.remoteAudio.playsInline=true;
    
    // Koppla remote audio stream till audio-elementet
    rt.pc.ontrack = function(event) {
      if(event.track.kind === 'audio') {
        rt.remoteAudio.srcObject = event.streams[0];
        rt.remoteAudio.play().catch(()=>{});
      }
    };
    
    rt.dc = rt.pc.createDataChannel('oai-events');

    rt.dc.onopen = () => {
      const instructions = `
Du är Coach Assistant för Linje 65.
Svara kort och på svenska. Punktlistor för steg.
ALLTID: Vänta tills användarens transkript är slut (final).
Därefter: Kalla funktionen search_manual med {query: EXAKT transkript}.
Ge inget sak-svar utan tool_result (om inte ren hälsning/småprat).
Om strict_answer -> läs upp ordagrant utan tillägg (max 2 meningar).
Om ingen strict_answer -> säg att det ej kan verifieras och be om precisering.
`.trim();
      const tools = [
        {
          type:'function', name:'search_manual',
          description:'Sök i Linje 65-manualen. Alltid före tekniskt svar.',
          parameters:{
            type:'object',
            properties:{
              query:{type:'string',description:'EXAKT senaste transkript'},
              k:{type:'integer',default:5},
              minSim:{type:'number',default:0.55}
            }, required:['query']
          }
        },
        {
          type:'function', name:'save_memory',
          description:'Spara stabil fakta / inställning.',
          parameters:{
            type:'object',
            properties:{ key:{type:'string'}, value:{type:'string'} },
            required:['key','value']
          }
        }
      ];
      rt.dc.send(JSON.stringify({ type:'session.update', session:{instructions, tools} }));
      append(pill('Realtime ansluten. Prata när som helst.'));
    };

    rt.dc.onmessage = e=>{
      try{ handleRealtimeMessage(JSON.parse(e.data)); }catch(err){ console.warn('Bad RT message', err); }
    };

    const {token, model} = await fetchJSON('/api/rt-token');
    append(pill('Realtime modell: '+model));

    const offer = await rt.pc.createOffer();
    await rt.pc.setLocalDescription(offer);
    const sdp = await fetch(`https://api.openai.com/v1/realtime?model=${encodeURIComponent(model)}`,{
      method:'POST',
      headers:{Authorization:`Bearer ${token}`,'Content-Type':'application/sdp','OpenAI-Beta':'realtime=v1'},
      body:offer.sdp
    }).then(r=>r.text());
    await rt.pc.setRemoteDescription({type:'answer', sdp});

    rt.connected=true;
    $('#rtBtn').style.display='none';
    $('#rtHangup').style.display='inline-block';
    status('Realtime ansluten');
  }catch(e){
    $('#rtStatus').textContent='Realtime misslyckades: '+(e.message||e);
    append(errorBubble('Fel vid anslutning: '+(e.message||e)));
  }
}

async function hangupRealtime(){
  try{
    rt.dc?.close();
    rt.pc?.getSenders()?.forEach(s=>s.track?.stop());
    rt.pc?.close();
    rt.mic?.getTracks()?.forEach(t=>t.stop());
  }catch{}
  const keepConv = rt.conversation_id;
  rt = {
    pc:null, dc:null, mic:null, remoteAudio:null, connected:false,
    conversation_id:keepConv, _msgCount:rt._msgCount,
    _ragBusy:false,_lastQuery:"",_lastToolCallId:null,
    cancelAutos:false, skipCancelForNextCreate:false, allowedResponseIds:new Set(),
    _lastUserText:"", _liveUserBuf:"", _pendingTool:null,_fallbackTimer:null
  };
  $('#rtBtn').style.display='inline-block';
  $('#rtHangup').style.display='none';
  $('#rtStatus').textContent='Inte ansluten';
  append(pill('Samtal avslutat.'));
}

function extractUserTextFromItem(item){
  try{
    if(!item || item.type!=='message' || item.role!=='user') return '';
    for(const p of (item.content||[])){
      if(p?.type==='input_text' && p.text) return p.text;
      if(p?.type==='text' && p.text) return p.text;
      if(p?.type==='input_audio_transcription' && p.text) return p.text;
      if(typeof p?.transcript==='string') return p.transcript;
    }
  }catch{}
  return '';
}
function extractAssistantTextFromItem(item){
  try{
    if(!item || item.type!=='message' || item.role!=='assistant') return '';
    for(const p of (item.content||[])){
      if(p?.type==='output_text' && p.text) return p.text;
      if(p?.type==='text' && p.text) return p.text;
    }
  }catch{}
  return '';
}
function resolveQueryFromState(args){
  let q=(args?.query||'').trim();
  if(!q && rt._liveUserBuf.trim()) q=rt._liveUserBuf.trim();
  if(!q && rt._lastUserText.trim()) q=rt._lastUserText.trim();
  if(!q && rt._lastQuery.trim()) q=rt._lastQuery.trim();
  return q;
}

function parkPendingTool({id,argsText,response_id}){
  rt._pendingTool = { id, argsText, response_id, deadline:Date.now()+WAIT_FOR_QUERY_MS, interval: rt._pendingTool?.interval || null };
  if(!rt._pendingTool.interval){
    rt._pendingTool.interval = setInterval(()=> tryRunPending('poll'), 120);
  }
  append(pill('⏳ Väntar på slutligt transkript'));
}

function tryRunPending(){
  const p=rt._pendingTool; if(!p) return;
  let args={}; try{ args=JSON.parse(p.argsText||'{}'); }catch{}
  const q=resolveQueryFromState(args);
  if(q){
    clearInterval(p.interval); rt._pendingTool=null;
    startRagTool(p.id, p.response_id);
    const patched=JSON.stringify({...args, query:q});
    runToolSearchManual({tool_call_id:p.id,response_id:p.response_id,argsText:patched});
    return;
  }
  if(Date.now()>p.deadline){
    clearInterval(p.interval); rt._pendingTool=null;
    append(pill('⌛ Timeout utan transkript'));
    if(p.response_id) rt.allowedResponseIds.add(p.response_id);
    rt.dc?.send(JSON.stringify({
      type:'conversation.item.create',
      item:{ type:'function_call_output', call_id:p.id, output: JSON.stringify({ok:false,error:'missing_query_timeout',need_user:true}) }
    }));
    rt.skipCancelForNextCreate=true;
    rt.dc?.send(JSON.stringify({ type:'response.create' }));
    rt.cancelAutos=false;
  }
}

function startRagTool(toolCallId, response_id){
  rt.cancelAutos=true;
  if(response_id) rt.allowedResponseIds.add(response_id);
  rt._ragBusy=true; rt._lastToolCallId=toolCallId;
  clearTimeout(ragTimer);
  ragTimer=setTimeout(()=>{ rt._ragBusy=false; rt.cancelAutos=false; }, RAG_TIMEOUT_MS);
}

function scheduleFallbackManual(txt){
  if(rt._ragBusy) return;
  if(rt._fallbackTimer) clearTimeout(rt._fallbackTimer);
  rt._fallbackTimer=setTimeout(()=>{
    if(!rt._ragBusy && !rt._pendingTool){
      rt._ragBusy=true; rt._lastQuery=txt; rt.cancelAutos=true;
      runToolSearchManual({tool_call_id:null,response_id:null,argsText:JSON.stringify({query:txt,k:5,minSim:0.55})});
    }
  }, 1200);
}

function parseArgsSafe(s){ try{return JSON.parse(s||'{}');}catch{return{};} }

function handleRealtimeMessage(msg){
  console.log('Mottaget event:', msg.type, msg);

  if(msg.type==='response.function_call_arguments.delta'){
    const id=msg.id||msg.tool_call_id||msg.response_id||'unknown';
    const prev=toolCalls.get(id)||{name:msg.name,argsText:''};
    prev.argsText+=(msg.delta||msg.arguments_delta||'');
    prev.name=prev.name||msg.name;
    if(msg.response_id) prev.response_id=msg.response_id;
    toolCalls.set(id,prev);
    return;
  }

  if(msg.type==='response.function_call_arguments.done'){
    const id=msg.id||msg.tool_call_id||'unknown';
    const tc=toolCalls.get(id)||{name:msg.name,argsText:''};
    if(msg.response_id){ tc.response_id=msg.response_id; toolCalls.set(id,tc); }
    let args={}; try{ args=JSON.parse(tc.argsText||'{}'); }catch{}
    if(tc.name){ append(pill(`TOOL CALL → ${tc.name} q="${(args.query||'').slice(0,32)}${(args.query||'').length>32?'…':''}"`)); }
    if(tc.name==='search_manual'){
      const qNow=resolveQueryFromState(args);
      if(!qNow){ parkPendingTool({id,argsText:tc.argsText,response_id:tc.response_id}); return; }
      if(rt._ragBusy || tc.launched) return;
      tc.launched=true; toolCalls.set(id,tc);
      startRagTool(id, tc.response_id);
      const patchedArgs=JSON.stringify({...args, query:qNow});
      runToolSearchManual({tool_call_id:id,response_id:tc.response_id,argsText:patchedArgs});
    } else if(tc.name==='save_memory'){
      if(tc.launched) return;
      tc.launched=true; toolCalls.set(id,tc);
      runToolSaveMemory(tc);
    }
    return;
  }

  if(msg.type==='response.created'){
    const rid=msg.response?.id||msg.response_id;
    if(rid && rt.allowedResponseIds.has(rid)) return;
    if(rt.cancelAutos){
      if(rt.skipCancelForNextCreate){
        rt.skipCancelForNextCreate=false;
      } else if(rid){
        rt.dc?.send(JSON.stringify({type:'response.cancel', response_id:rid}));
        append(pill('🛑 Auto-respons stoppad'));
      }
    }
    return;
  }

  if(msg.type==='conversation.item.created'){
    if(msg.item?.role==='user'){
      const utext = extractUserTextFromItem(msg.item).trim();
      if(utext){
        rt._lastUserText=utext;
        append(bubble(utext,'user'));
        logMsg('user',utext,'voice',msg);
        if(rt._pendingTool) tryRunPending('final');
        scheduleFallbackManual(utext);
      }
    }
    if(msg.item?.role==='assistant'){
      const atext=extractAssistantTextFromItem(msg.item);
      if(atext){ append(bubble(atext,'assistant')); logMsg('assistant',atext,'voice',msg); }
    }
    return;
  }

  if(msg.type==='conversation.item.input_audio_transcription.delta'){
    const chunk=msg.delta||msg.text||msg.transcript||'';
    if(chunk) rt._liveUserBuf=(rt._liveUserBuf||'')+chunk;
    return;
  }

  if(msg.type==='input_audio_buffer.committed'){
    if(rt._liveUserBuf.trim()){
      rt._lastUserText=rt._liveUserBuf.trim();
      append(pill('🎤 Final (committed)'));
      if(rt._pendingTool) tryRunPending('final');
      scheduleFallbackManual(rt._lastUserText);
      rt._liveUserBuf='';
    }
    return;
  }

  if(msg.type==='conversation.item.input_audio_transcription.completed'){
    const full = (msg.transcript?.text || msg.text || msg.transcript || '').trim();
    if(full){
      rt._lastUserText=full; rt._liveUserBuf='';
      append(bubble(full,'user'));
      logMsg('user',full,'voice',msg);
      if(rt._pendingTool) tryRunPending('final');
      scheduleFallbackManual(full);
    }
    return;
  }

  if(msg.type==='response.output_text.done'){
    const text=msg.output_text||msg.text||'';
    if(text.trim()){
      append(bubble(text,'assistant'));
      logMsg('assistant',text,'voice',msg);
    }
    cleanupAfterResponse(msg.response_id);
    return;
  }

  if(msg.type==='response.completed' || msg.type==='response.error' || msg.type==='error'){
    cleanupAfterResponse(msg.response_id);
    if(msg.type==='error') append(errorBubble('RT fel: '+(msg.error?.message||'okänt')));
    return;
  }
}

function cleanupAfterResponse(response_id){
  rt._ragBusy=false; rt.cancelAutos=false; rt.skipCancelForNextCreate=false;
  if(response_id) rt.allowedResponseIds.delete(response_id);
  clearTimeout(ragTimer);
}

function speakVerbatim(text){
  const toSay=`LÄS UPP EXAKT: """${text}"""`;
  rt.skipCancelForNextCreate=true;
  rt.dc?.send(JSON.stringify({
    type:'response.create',
    response:{ modalities:['audio','text'], instructions:toSay, metadata:{source:'rag'} }
  }));
}

async function runToolSearchManual(tc){
  const args = parseArgsSafe(tc.argsText);
  const k = args.k ?? 5;
  const q = resolveQueryFromState(args);

  if(!q){
    if(tc.tool_call_id){
      rt.dc?.send(JSON.stringify({
        type:'conversation.item.create',
        item:{ type:'function_call_output', call_id:tc.tool_call_id, output: JSON.stringify({ok:false,error:'missing_query',need_user:true}) }
      }));
      rt.skipCancelForNextCreate=true;
      rt.dc?.send(JSON.stringify({ type:'response.create' }));
      append(pill('⚠️ search_manual: tom query'));
    } else {
      speakVerbatim('Jag uppfattade inte frågan. Kan du upprepa?');
    }
    rt._ragBusy=false; clearTimeout(ragTimer); return;
  }

  const body={ query:q, k, topK:k, minSim:args.minSim ?? 0.55 };

  try{
    const data = await fetchJSON('/api/search-manual',{
      method:'POST',headers:{'Content-Type':'application/json'},
      body:JSON.stringify(body)
    });
    append(pill(`RAG: count=${data.count||0}${data.fallback?' (fallback)':''} • top1=${(data.snippets?.[0]?.score??0).toFixed(2)} • q="${q.slice(0,32)}${q.length>32?'…':''}"`));

    let strict='', bestSentence='';
    if((data.count||0)>0){
      strict = (data.snippets[0].text||'').split(/\n+/)[0].trim().slice(0,220);
      bestSentence = strict;
    }
    const sources=(data.snippets||[]).slice(0,5).map(s=>({title:s.title||'manual',idx:s.idx,score:s.score}));

    const out={
      ok:true,
      strict_answer: strict || undefined,
      best_sentence: bestSentence || undefined,
      fallback: !!data.fallback,
      top_score:(data.snippets?.[0]?.score??null),
      sources
    };

    if(tc.tool_call_id){
      rt.dc?.send(JSON.stringify({
        type:'conversation.item.create',
        item:{ type:'function_call_output', call_id:tc.tool_call_id, output: JSON.stringify(out) }
      }));
      rt.skipCancelForNextCreate=true;
      rt.dc?.send(JSON.stringify({ type:'response.create' }));
      append(pill('📤 Skickade tool-output'));
    } else {
      if(out.strict_answer){
        const s0=sources[0]||{};
        append(bubble(`${out.strict_answer}\nKälla: ${(s0.title||'manual')} idx:${s0.idx??'?'} score:${(s0.score??0).toFixed(2)}`,'assistant'));
      } else {
        speakVerbatim('Jag kan inte verifiera det i manualen. Kan du precisera område eller felkod?');
      }
    }
  }catch(err){
    append(errorBubble('Manual-sök fel: '+(err.message||err)));
    if(!tc.tool_call_id){
      speakVerbatim('Kunde inte nå manualen just nu. Försök igen snart.');
    } else {
      rt.dc?.send(JSON.stringify({
        type:'conversation.item.create',
        item:{ type:'function_call_output', call_id:tc.tool_call_id, output: JSON.stringify({ ok:false, error:'search_manual failed' }) }
      }));
      rt.skipCancelForNextCreate=true;
      rt.dc?.send(JSON.stringify({ type:'response.create' }));
    }
  }finally{
    rt._ragBusy=false; clearTimeout(ragTimer);
  }
}

async function runToolSaveMemory(tc){
  const args=parseArgsSafe(tc.argsText);
  try{
    await fetch('/api/save-memory',{
      method:'POST',headers:{'Content-Type':'application/json'},
      body:JSON.stringify({userId:operatorId,key:args.key,value:args.value})
    });
    if(tc.tool_call_id){
      rt.dc?.send(JSON.stringify({
        type:'conversation.item.create',
        item:{ type:'function_call_output', call_id:tc.tool_call_id, output: JSON.stringify({ ok:true }) }
      }));
      rt.skipCancelForNextCreate=true;
      rt.dc?.send(JSON.stringify({ type:'response.create' }));
    } else {
      rt.skipCancelForNextCreate=true;
      rt.dc?.send(JSON.stringify({
        type:'response.create',
        response:{modalities:['audio','text'],instructions:`Noterat: ${args.key} = ${args.value}.`}
      }));
    }
  }catch(e){
    if(tc.tool_call_id){
      rt.dc?.send(JSON.stringify({
        type:'conversation.item.create',
        item:{ type:'function_call_output', call_id:tc.tool_call_id, output: JSON.stringify({ ok:false, error:'save_memory_failed' }) }
      }));
      rt.skipCancelForNextCreate=true;
      rt.dc?.send(JSON.stringify({ type:'response.create' }));
    } else {
      speakVerbatim('Kunde inte spara minnet just nu.');
    }
  }
}

$('#sendTextBtn').onclick = sendQuickText;
$('#quickText').addEventListener('keydown', e=>{ if(e.key==='Enter') sendQuickText(); });

function sendQuickText(){
  const t=$('#quickText').value.trim(); if(!t) return;
  $('#quickText').value='';
  append(bubble('➤ '+t,'user'));
  rt._lastUserText=t;
  sendTextToRealtime(t);
}

function sendTextToRealtime(text){
  if(!rt.dc || rt.dc.readyState!=='open'){ append(pill('Inte ansluten.')); return; }
  rt.dc.send(JSON.stringify({type:'input_text', text}));
  if(text.split(/\s+/).length<2) return;
  if(!rt._ragBusy && text!==rt._lastQuery){
    rt._ragBusy=true; rt._lastQuery=text; rt.cancelAutos=true;
    clearTimeout(ragTimer);
    ragTimer=setTimeout(()=>{ rt._ragBusy=false; rt.cancelAutos=false; }, RAG_TIMEOUT_MS);
    runToolSearchManual({tool_call_id:null,response_id:null,argsText:JSON.stringify({query:text,k:5,minSim:0.55})});
  }
}

$('#manualBtn').addEventListener('click', testManualSearch);
$('#manualQuery').addEventListener('keydown', e=>{ if(e.key==='Enter') testManualSearch(); });
async function testManualSearch(){
  const q=$('#manualQuery').value.trim();
  if(!q){ append(pill('Skriv en fråga för manualen.')); return; }
  append(bubble('🔎 Manual: '+q,'user'));
  try{
    const data=await fetchJSON('/api/search-manual',{
      method:'POST',headers:{'Content-Type':'application/json'},
      body:JSON.stringify({query:q,k:5,topK:5,minSim:0.55})
    });
    append(pill(`RAG: count=${data.count||0}${data.fallback?' (fallback)':''} • top1=${(data.snippets?.[0]?.score??0).toFixed(2)}`));
    if(!data.count){ append(bubble('Inga träffar i manualen.','assistant')); return; }
    append(bubble((data.snippets[0].text||'').slice(0,240),'assistant'));
  }catch(e){
    append(errorBubble('Manual-sök fel: '+e.message));
  }
}
  </script>
</body>
</html>
