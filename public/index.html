<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Coach Assistant</title>
  <link rel="icon" href="data:,">
  <style>
    :root { --bg:#111; --fg:#fff; --acc:#00aaff; --mut:#bbb; }
    body { font-family: system-ui, sans-serif; padding: 2rem; background: var(--bg); color: var(--fg); }
    .row { display:flex; gap:1rem; align-items:center; flex-wrap:wrap; }
    button { padding:.9rem 1.2rem; font-size:1rem; cursor:pointer; border:none; border-radius:10px; background:var(--acc); color:#fff; }
    #output { margin-top: 1rem; font-size: 1.05rem; }
    .status { font-size:.95rem; color:#ddd }
    .pill { background:#1a1a1a; border:1px solid #333; padding:.7rem .9rem; border-radius:10px; margin-top:.6rem }
    .dot { width:10px; height:10px; border-radius:50%; display:inline-block; margin-right:.5rem; vertical-align:middle }
    .listen { background:#22c55e } .think { background:#facc15 } .speak { background:#60a5fa } .idle { background:#6b7280 }
  </style>
</head>
<body>
  <h1>Coach Assistant</h1>
  <p class="status"><span class="dot idle"></span><span id="recStatus">Redo – tryck start, prata normalt för att avbryta svar.</span></p>

  <div class="row">
    <button id="startBtn">▶️ Starta röstloop</button>
    <button id="stopBtn" style="background:#ef4444;display:none">⏹️ Stoppa</button>
  </div>

  <div id="output"></div>

  <script>
    const startBtn = document.getElementById('startBtn');
    const stopBtn  = document.getElementById('stopBtn');
    const output   = document.getElementById('output');
    const recStatus= document.getElementById('recStatus');

    // -------- STATE --------
    // IDLE → LISTENING → THINKING → SPEAKING → LISTENING ...
    let state = 'IDLE';
    let running = false;

    // Mic / analyser
    let micStream = null, mediaRecorder = null, chunks = [];
    let analyser = null, vadData = null, audioCtxVAD = null;

    // Level monitor (kör kontinuerligt under sessionen)
    let levelMonitor = null;

    // TTS
    let ttsCtx = null, ttsSource = null;

    // Trösklar (tuning för naturlig barge-in)
    const SILENCE_THRESHOLD = 12;   // tystnadsnivå (0–255)
    const SILENCE_HOLD_MS   = 900;  // hur länge tyst innan vi skickar
    const MAX_RECORD_MS     = 12000;

    // Barge-in: adaptiv mot TTS-läckage
    let speakBaseline = 0;          // EMA på “läcknivå”
    const BARGE_MARGIN      = 6;    // så mycket över baseline räcker
    const BARGE_MIN_LEVEL   = 18;   // kräver minst den här nivån (undviker brus)
    const BARGE_HOLD_MS     = 250;  // hur länge du behöver prata för att bryta
    let bargeHold = 0;

    function setStatus(mode, text) {
      const dotClass = mode === 'LISTENING' ? 'listen' : mode === 'THINKING' ? 'think' : mode === 'SPEAKING' ? 'speak' : 'idle';
      recStatus.previousElementSibling.className = `dot ${dotClass}`;
      recStatus.textContent = text;
    }

    // -------- Utils --------
    function rmsLevel(uint8PCM) {
      let sum = 0;
      for (let i = 0; i < uint8PCM.length; i++) { const v = uint8PCM[i] - 128; sum += v * v; }
      const rms = Math.sqrt(sum / uint8PCM.length);
      return Math.min(255, Math.max(0, Math.round(rms * 6)));
    }

    // -------- TTS --------
    function stopTTS() {
      try { ttsSource && ttsSource.stop(); } catch {}
      ttsSource = null;
      if (ttsCtx) { try { ttsCtx.close(); } catch {} }
      ttsCtx = null;
    }

    async function speak(text) {
      stopTTS();
      state = 'SPEAKING';
      setStatus(state, 'Svarar… (prata normalt för att avbryta)');

      try {
        const res = await fetch('/api/tts', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text })
        });
        if (!res.ok) throw new Error('Fel vid TTS-svar');

        const blob = await res.blob();
        const arrayBuffer = await blob.arrayBuffer();

        ttsCtx = new (window.AudioContext || window.webkitAudioContext)();
        const gainNode = ttsCtx.createGain();
        gainNode.gain.value = 1.6; // lite lägre än 2.0 för mindre läck

        ttsSource = ttsCtx.createBufferSource();
        const audioBuffer = await ttsCtx.decodeAudioData(arrayBuffer);
        ttsSource.buffer = audioBuffer;
        ttsSource.connect(gainNode).connect(ttsCtx.destination);
        ttsSource.onended = () => { if (running) startListening(); };
        ttsSource.start(0);

        // init baseline för barge-in
        speakBaseline = 0;
        bargeHold = 0;
      } catch (err) {
        console.error('TTS-fel:', err);
        output.insertAdjacentHTML('beforeend', "<div class='pill'>Kunde inte spela upp ljud.</div>");
        if (running) startListening();
      }
    }

    // -------- CHAT --------
    async function askAssistant(text) {
      state = 'THINKING';
      setStatus(state, 'Bearbetar…');
      output.insertAdjacentHTML('beforeend', `<div class="pill"><strong>Du sa:</strong> ${text}</div>`);

      try {
        const res = await fetch('/api/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ message: text })
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data?.error || 'Chat-fel');

        const answer = (typeof data.reply === 'string') ? data.reply
                      : data.reply?.reply || 'Jag kunde inte formulera ett svar.';
        output.insertAdjacentHTML('beforeend', `<div class="pill"><strong>Svar:</strong><br>${answer}</div>`);
        await speak(answer);
      } catch (err) {
        console.error('Chat-fel:', err);
        output.insertAdjacentHTML('beforeend', `<div class="pill">Kunde inte få svar från AI.</div>`);
        if (running) startListening();
      }
    }

    // -------- Whisper --------
    async function transcribe(blob) {
      const formData = new FormData();
      formData.append('audio', blob, 'audio.webm');
      const res = await fetch('/api/whisper', { method: 'POST', body: formData });
      const data = await res.json();
      if (!res.ok) throw new Error(data?.error || 'Transkriberingsfel');
      return (data.text || '').trim();
    }

    // -------- Level monitor (kör hela sessionen) --------
    function startLevelMonitor() {
      if (levelMonitor) return;
      levelMonitor = setInterval(() => {
        if (!analyser || !vadData) return;
        analyser.getByteTimeDomainData(vadData);
        const level = rmsLevel(vadData);

        if (state === 'SPEAKING') {
          // EMA för baseline (läcknivå från högtalare)
          speakBaseline = speakBaseline ? (0.85 * speakBaseline + 0.15 * level) : level;
          const threshold = Math.max(BARGE_MIN_LEVEL, speakBaseline + BARGE_MARGIN);

          if (level > threshold) {
            bargeHold += 100;
            if (bargeHold >= BARGE_HOLD_MS) {
              // naturlig barge-in
              stopTTS();
              startListening();
              bargeHold = 0;
            }
          } else {
            bargeHold = 0;
          }
        }
      }, 100);
    }
    function stopLevelMonitor() { if (levelMonitor) { clearInterval(levelMonitor); levelMonitor = null; } }

    // -------- Listening --------
    async function startListening() {
      if (!running) return;
      stopTTS(); // säkerställ tyst
      state = 'LISTENING';
      setStatus(state, 'Lyssnar… (bli tyst för att skicka)');

      chunks = [];
      const startedAt = performance.now();
      let silentMs = 0;

      mediaRecorder = new MediaRecorder(micStream, { mimeType: 'audio/webm' });
      mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) chunks.push(e.data); };
      mediaRecorder.onstop = async () => {
        const blob = new Blob(chunks, { type: 'audio/webm' });
        if (!running) return;
        try {
          const text = await transcribe(blob);
          if (text) await askAssistant(text);
          else {
            output.insertAdjacentHTML('beforeend', "<div class='pill'>Hörde inget tydligt. Prova igen.</div>");
            if (running) startListening();
          }
        } catch (err) {
          console.error('Whisper-fel:', err);
          output.insertAdjacentHTML('beforeend', "<div class='pill'>Kunde inte transkribera ljudet.</div>");
          if (running) startListening();
        }
      };
      mediaRecorder.start();

      // enkel VAD i lyssningsläge – auto-stop på tystnad/timeout
      const vadListen = setInterval(() => {
        analyser.getByteTimeDomainData(vadData);
        const level = rmsLevel(vadData);
        if (level < SILENCE_THRESHOLD) silentMs += 100; else silentMs = 0;

        if (silentMs >= SILENCE_HOLD_MS || performance.now() - startedAt > MAX_RECORD_MS) {
          clearInterval(vadListen);
          try { mediaRecorder.state !== 'inactive' && mediaRecorder.stop(); } catch {}
        }
      }, 100);
    }

    // -------- Start/Stop loop --------
    async function startLoop() {
      if (running) return;
      running = true;
      startBtn.style.display = 'none';
      stopBtn.style.display  = 'inline-block';

      try {
        micStream = await navigator.mediaDevices.getUserMedia({
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: false
          }
        });
      } catch (e) {
        output.insertAdjacentHTML('beforeend', "<div class='pill'>Mikrofon kunde inte startas (behörighet?).</div>");
        running = false;
        startBtn.style.display = 'inline-block';
        stopBtn.style.display  = 'none';
        return;
      }

      audioCtxVAD = new (window.AudioContext || window.webkitAudioContext)();
      const src = audioCtxVAD.createMediaStreamSource(micStream);
      analyser = audioCtxVAD.createAnalyser();
      analyser.fftSize = 2048;
      vadData = new Uint8Array(analyser.fftSize);
      src.connect(analyser);

      startLevelMonitor(); // alltid aktiv under sessionen
      startListening();
    }

    function stopLoop() {
      running = false;
      state = 'IDLE';
      setStatus(state, 'Stoppad');
      startBtn.style.display = 'inline-block';
      stopBtn.style.display  = 'none';

      stopLevelMonitor();
      stopTTS();
      try { mediaRecorder && mediaRecorder.state !== 'inactive' && mediaRecorder.stop(); } catch {}
      try { analyser && analyser.disconnect(); } catch {}
      try { audioCtxVAD && audioCtxVAD.close(); } catch {}
      analyser = null; audioCtxVAD = null; vadData = null;

      if (micStream) { micStream.getTracks().forEach(t => t.stop()); micStream = null; }
    }

    startBtn.addEventListener('click', startLoop);
    stopBtn.addEventListener('click', stopLoop);
    window.addEventListener('keydown', (e) => { if (e.key === 'Escape') stopLoop(); });
  </script>
</body>
</html>
