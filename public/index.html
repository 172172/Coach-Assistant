<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Coach Assistant – Realtime + Assistants (Hybrid)</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:#0b0f19;color:#eef;display:flex;flex-direction:column;align-items:center;margin:0;padding:24px;gap:16px}
    .card{width:min(920px,95vw);background:#11182a;border:1px solid #1c2540;border-radius:16px;box-shadow:0 8px 28px rgba(0,0,0,.35);padding:16px}
    h1{margin:8px 0 0;font-weight:600} .sub{opacity:.8;margin:0 0 16px}
    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    button{background:#2b5cff;border:0;color:#fff;padding:10px 14px;border-radius:12px;font-weight:600;cursor:pointer}
    button.secondary{background:#233055}
    .log{height:260px;overflow:auto;background:#0c1222;border-radius:12px;padding:12px;font-family:ui-monospace,Menlo,Consolas,monospace}
    .pill{display:inline-block;padding:4px 8px;border:1px solid #2a355a;border-radius:999px;margin-right:6px;font-size:12px}
    .small{font-size:12px;opacity:.8}
  </style>
</head>
<body>
  <div class="card">
    <h1>Coach Assistant – Linje 65</h1>
    <p class="sub">Realtime röst + verktyg: <span class="pill">ask_assistant</span></p>
    <div class="row">
      <button id="btnConnect">Anslut</button>
      <button id="btnMic" disabled>Starta Mic</button>
      <button id="btnHang" class="secondary" disabled>Lägg på</button>
    </div>
    <div class="row small"><span id="status">Status: frånkopplad</span></div>
    <div class="log" id="log"></div>
  </div>

<script>
const logEl = document.getElementById('log');
function log(...args){
  const line = document.createElement('div');
  line.textContent = args.map(a => typeof a==='string'?a:JSON.stringify(a)).join(' ');
  logEl.appendChild(line); logEl.scrollTop = logEl.scrollHeight;
}

let pc, dc, micStream;
let threadId = null; // återanvänd tråd per samtal

async function getRtToken(){
  const res = await fetch('/api/rt-token');
  if(!res.ok) throw new Error('rt-token fail');
  return res.json(); // { url, client_secret, instructions }
}

function send(payload){
  if (dc && dc.readyState==='open') {
    dc.send(JSON.stringify(payload));
  } else {
    console.warn('DataChannel not open; dropping:', payload?.type);
  }
}

async function connect(){
  const { url, client_secret, instructions } = await getRtToken();

  pc = new RTCPeerConnection();
  dc = pc.createDataChannel('oai-events');
  dc.onmessage = onMessage;
  dc.onopen = () => {
    log('DataChannel open – skickar session.update');
    send({ type:'session.update', session:{
      instructions: instructions + "\n\nREGLER:\n- Använd ALLTID ask_assistant för tekniska frågor om linje/maskiner/procedurer.\n- Vänta alltid på tool_result innan du talar.\n- Om manual saknas: säg ‘Oklar information – behöver uppdaterad manual.’\n- Svara kort på svenska.",
      modalities:["audio","text"],
      input_audio_transcription:{ model:"whisper-1" },
      turn_detection:{ type:"server_vad", threshold:0.5, silence_duration_ms:650 },
      tools:[{
        type:"function",
        name:"ask_assistant",
        description:"Fråga Assistants API (med File Search) och returnera grundat svar.",
        parameters:{
          type:"object",
          properties:{ query:{ type:"string" } },
          required:["query"]
        }
      }],
      tool_choice:"auto"
    }});
  };

  const audio = document.createElement('audio');
  audio.autoplay = true;
  pc.ontrack = e => { audio.srcObject = e.streams[0]; };

  micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
  micStream.getTracks().forEach(t => pc.addTrack(t, micStream));

  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);

  const sdpRes = await fetch(url, {
    method:'POST',
    body: offer.sdp,
    headers:{ 'Authorization': `Bearer ${client_secret}`, 'Content-Type':'application/sdp' }
  });
  const answer = { type:'answer', sdp: await sdpRes.text() };
  await pc.setRemoteDescription(answer);

  log('Ansluten till Realtime.');
  document.getElementById('status').textContent='Status: ansluten';
  document.getElementById('btnMic').disabled=false;
  document.getElementById('btnHang').disabled=false;
}

function hang(){
  if (pc) pc.close();
  if (micStream) micStream.getTracks().forEach(t=>t.stop());
  pc=null; micStream=null; threadId=null;
  document.getElementById('status').textContent='Status: frånkopplad';
  document.getElementById('btnMic').disabled=true;
  document.getElementById('btnHang').disabled=true;
}

let micOn=false;
function toggleMic(){
  if(!micStream) return;
  micOn=!micOn;
  micStream.getAudioTracks().forEach(t=> t.enabled = micOn);
  document.getElementById('btnMic').textContent = micOn? 'Stoppa Mic' : 'Starta Mic';
}

async function onMessage(evt){
  const m = JSON.parse(evt.data);
  if(m.type==='response.created'){ log('response.created'); }
  if(m.type==='response.completed'){ log('response.completed'); }

  if(m.type==='response.function_call'){
    const { id:function_call_id, name, arguments: rawArgs } = m.function_call;
    log('Tool call:', name, 'args:', rawArgs);

    // defensiv parsning av arguments (kan komma som sträng)
    let toolArgs = rawArgs;
    if (typeof toolArgs === 'string') {
      try { toolArgs = JSON.parse(toolArgs); } catch { toolArgs = {}; }
    }
    const userQuery = toolArgs?.query || '';

    if(name==='ask_assistant'){
      try{
        const res = await fetch('/api/ask-assistant', {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({
            query: userQuery,
            thread_id: threadId,
            context: { current_line: 65 }
          })
        });

        const data = await res.json();
        if (data.thread_id && !threadId) threadId = data.thread_id;

        // payload som ska tillbaka till modellen
        const payload = {
          answer: data?.answer || '',
          citations: data?.citations || [],
          notice: data?.notice || null
        };

        // 1) output MÅSTE vara en JSON-sträng
        send({
          type:'response.function_call_output',
          function_call_id,
          output: JSON.stringify(payload)
        });
        log('function_call_output skickad (stringified). citations:', (data?.citations?.length||0), 'notice:', data?.notice || '—');

        // 2) trigga modellen att fortsätta tala på tool-resultatet
        send({ type:'response.create' });
      }catch(e){
        const errPayload = { error: String(e) };
        send({ type:'response.function_call_output', function_call_id, output: JSON.stringify(errPayload) });
        log('Tool error returnerad:', String(e));

        // be modellen svara något begripligt om felet
        send({ type:'response.create' });
      }
    }
  }
}

document.getElementById('btnConnect').onclick = connect;
document.getElementById('btnMic').onclick = toggleMic;
document.getElementById('btnHang').onclick = hang;
</script>
</body>
</html>
