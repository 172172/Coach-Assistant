
<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Coach Assistant – Linje 65 (Realtime, Stabil)</title>
  <style>
    :root{--bg:#0b0f14;--panel:#121821;--text:#e6edf3;--muted:#9fb0c3;--accent:#5eead4;--danger:#f87171;--pill:#182232}
    html,body{height:100%}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Noto Sans","Helvetica Neue",Arial;background:radial-gradient(1200px 600px at 20% 0%,#0e1621,#0b0f14 75%);color:var(--text)}
    .wrap{max-width:980px;margin:0 auto;padding:24px}
    header{display:flex;align-items:center;justify-content:space-between;gap:16px;margin-bottom:16px}
    header .title{font-size:20px;font-weight:700;letter-spacing:.3px}
    .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    button{appearance:none;border:none;padding:10px 14px;border-radius:12px;cursor:pointer;font-weight:600}
    .primary{background:var(--accent);color:#0a0f14}
    .ghost{background:#0d1520;color:var(--text);border:1px solid #233146}
    .muted{color:var(--muted);font-size:13px}
    .row{display:flex;gap:10px;align-items:center}
    input[type="text"],input[type="search"]{background:#0d1622;color:#e6edf3;border:1px solid #243244;border-radius:10px;padding:10px 12px}
    .pill{background:var(--pill);color:var(--text);padding:8px 12px;border-radius:999px;display:inline-block;margin:6px 6px 0 0;font-size:12px;border:1px solid #26364a}
    .panel{background:var(--panel);border:1px solid #233146;border-radius:16px;padding:14px}
    #output{display:flex;flex-direction:column;gap:10px;margin-top:14px}
    .bubble{background:#0f1722;border:1px solid #213145;border-radius:16px;padding:12px 14px;white-space:pre-wrap;line-height:1.45}
    .bubble.user{background:#0f1a27;border-color:#24415a}
    .bubble.assistant{background:#0f1823;border-color:#2c3f57}
    .bubble.error{background:#1b0f12;border-color:#4a1f2a}
    .vis{height:10px;background:#0e1420;border-radius:9999px;overflow:hidden;border:1px solid #213145}
    .vis>b{display:block;height:100%;width:6%;background:linear-gradient(90deg,#85f3d5,#4dd4ff);transition:width .08s linear}
    footer{margin-top:24px;color:var(--muted);font-size:12px}
    .flex{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    code.small{font-size:11px;opacity:.85}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">🦾 Coach Assistant – Linje 65 (Realtime, Stabil)</div>
      <div class="controls">
        <button class="primary" id="rtBtn">Anslut Realtime</button>
        <button class="ghost" id="rtHangup" style="display:none">Lägg på</button>
      </div>
    </header>

    <div class="panel">
      <div class="flex">
        <div id="rtStatus" class="pill">Inte ansluten</div>
        <div class="vis" style="flex:1 1 220px; min-width:220px"><b id="micBar"></b></div>
      </div>

      <div class="row" style="margin-top:10px">
        <input id="quickText" type="search" placeholder="Skicka text till assistenten (enter)" style="flex:1" />
        <button class="ghost" id="sendTextBtn">Skicka</button>
      </div>

      <div id="output"></div>
    </div>

    <footer>
      Röstflöde: <code class="small">transcription.completed → function_call.created (namn + call_id) → arguments.done → function_call_output(call_id) → response.create</code>
    </footer>
  </div>

  <script>
    // ===== Helpers =====
    const $ = s => document.querySelector(s);
    const append = el => { $('#output').appendChild(el); el.scrollIntoView({behavior:'smooth',block:'end'}); };
    const pill = t => { const d=document.createElement('div'); d.className='pill'; d.textContent=t; return d; };
    const bubble = (t,role='assistant') => { const d=document.createElement('div'); d.className='bubble '+role; d.textContent=t; return d; };
    const errorBubble = t => { const d=document.createElement('div'); d.className='bubble error'; d.textContent=t; return d; };
    async function fetchJSON(url, opts){ const r=await fetch(url,opts); const txt=await r.text(); let j; try{j=JSON.parse(txt)}catch{throw new Error(`${r.status} ${r.statusText}: ${txt.slice(0,200)}`)} if(!r.ok||j?.ok===false) throw new Error(j?.error||j?.message||`${r.status} ${r.statusText}`); return j; }

    // ===== State =====
    let rt = {
      pc:null, dc:null, mic:null, remoteAudio:null, connected:false,
      calls: new Map(),               // key = call_id, value = {name,argsText}
      lastUserText: '',               // senaste transkript / text
      partialByItem: new Map(),       // item_id -> pågående transkript
    };

    // mic viz
    let micAnalyser, micData;
    function setupMicViz(stream){
      try{
        const ctx=new (window.AudioContext||window.webkitAudioContext)();
        const src=ctx.createMediaStreamSource(stream);
        micAnalyser=ctx.createAnalyser(); micAnalyser.fftSize=512; micAnalyser.smoothingTimeConstant=0.8;
        src.connect(micAnalyser); micData=new Uint8Array(micAnalyser.frequencyBinCount);
        const bar=$('#micBar');
        (function loop(){
          if(!micAnalyser) return;
          micAnalyser.getByteTimeDomainData(micData);
          let peak=0; for(let i=0;i<micData.length;i++){ const v=Math.abs(micData[i]-128)/128; if(v>peak) peak=v; }
          bar.style.width=Math.min(98,(peak*100*1.6)+6)+'%';
          requestAnimationFrame(loop);
        })();
      }catch{}
    }

    // ===== Connect / Hangup =====
    $('#rtBtn').addEventListener('click', connectRealtime);
    $('#rtHangup').addEventListener('click', hangupRealtime);

    async function connectRealtime(){
      const status=t=>$('#rtStatus').textContent=t;
      try{
        rt.mic = await navigator.mediaDevices.getUserMedia({
          audio: { channelCount:1, noiseSuppression:true, echoCancellation:true, autoGainControl:false, sampleRate:48000 }
        });
        setupMicViz(rt.mic);

        rt.pc=new RTCPeerConnection();
        rt.pc.addTransceiver('audio', { direction:'recvonly' });
        rt.mic.getTracks().forEach(t=>rt.pc.addTrack(t,rt.mic));

        rt.remoteAudio=new Audio(); rt.remoteAudio.autoplay=true; rt.remoteAudio.playsInline=true; rt.remoteAudio.muted=false;
        rt.pc.ontrack=e=>{ rt.remoteAudio.srcObject=e.streams[0]; rt.remoteAudio.play().catch(()=>{}); append(pill('🔊 Mottar röst från assistenten')); };

        rt.dc=rt.pc.createDataChannel('oai-events');
        rt.dc.onopen=()=>{
          rt.dc.send(JSON.stringify({
            type:'session.update',
            session:{
              voice:'verse',
              modalities:['audio','text'],
              turn_detection:{ type:'server_vad', threshold:0.6, silence_duration_ms:550, prefix_padding_ms:200 },
              input_audio_transcription:{ model:'gpt-4o-transcribe', language:'sv' },
              tool_choice:'auto',
              tools:[{
                type:'function', name:'search_manual',
                description:'Sök i manualen och returnera snippets.',
                parameters:{
                  type:'object',
                  properties:{
                    query:{type:'string'}, k:{type:'integer'},
                    minSim:{type:'number'}, heading:{type:'string'},
                    restrictToHeading:{type:'boolean'}
                  },
                  required:['query']
                }
              }],
              instructions:'Anropa alltid search_manual först och svara endast baserat på snippets.'
            }
          }));
          append(pill('Realtime ansluten.'));
        };
        rt.dc.onmessage=(e)=>{ try{ handleRealtimeMessage(JSON.parse(e.data)); }catch(err){ console.warn('parse',err); } };

        const {token, model}=await fetchJSON('/api/rt-token');
        append(pill('Realtime modell: '+model));
        const offer=await rt.pc.createOffer(); await rt.pc.setLocalDescription(offer);
        const sdp=await fetch(`https://api.openai.com/v1/realtime?model=${encodeURIComponent(model)}`,{
          method:'POST',
          headers:{Authorization:`Bearer ${token}`,'Content-Type':'application/sdp','OpenAI-Beta':'realtime=v1'},
          body:offer.sdp
        }).then(r=>r.text());
        await rt.pc.setRemoteDescription({type:'answer', sdp});

        rt.connected=true; $('#rtBtn').style.display='none'; $('#rtHangup').style.display='inline-block'; status('Realtime ansluten');
      }catch(e){ console.error(e); $('#rtStatus').textContent=`Realtime misslyckades: ${e?.message||e}`; append(errorBubble('Fel vid anslutning: '+(e?.message||e))); }
    }

    async function hangupRealtime(){
      try{
        rt.dc?.close();
        rt.pc?.getSenders()?.forEach(s=>s.track?.stop());
        rt.pc?.close(); rt.mic?.getTracks()?.forEach(t=>t.stop());
        micAnalyser=null;
      }catch{}
      rt={ pc:null, dc:null, mic:null, remoteAudio:null, connected:false, calls:new Map(), lastUserText:'', partialByItem:new Map() };
      $('#rtBtn').style.display='inline-block'; $('#rtHangup').style.display='none'; $('#rtStatus').textContent='Inte ansluten'; append(pill('Samtal avslutat.'));
    }

    // ===== Text input (test) =====
    $('#sendTextBtn').onclick = sendQuickText;
    $('#quickText').addEventListener('keydown', e => { if(e.key==='Enter') sendQuickText(); });
    function sendQuickText(){
      const t=$('#quickText').value.trim(); if(!t) return;
      rt.lastUserText = t;
      $('#quickText').value=''; append(bubble('➤ '+t,'user'));
      if(!rt?.dc || rt.dc.readyState!=='open'){ append(pill('Inte ansluten.')); return; }
      rt.dc.send(JSON.stringify({ type:'input_text', text:t }));
      rt.dc.send(JSON.stringify({ type:'response.create' })); // trigga modell för text
    }

    // ===== Realtime events =====
    function handleRealtimeMessage(msg){
      // debug
      if (msg?.type && (
        msg.type.startsWith('response.function_call') ||
        msg.type.startsWith('conversation.item.input_audio_transcription') ||
        msg.type==='response.created' || msg.type==='response.completed'
      )) append(pill('EVT: '+msg.type));

      // --- RÖST: transkriptions-delta ---
      if (msg.type === 'conversation.item.input_audio_transcription.delta') {
        const itemId = msg.item_id || msg.item?.id || 'unknown';
        const delta = (msg.delta || msg.text || '').trim();
        if (delta) {
          const prev = rt.partialByItem.get(itemId) || '';
          const cur = prev + delta;
          rt.partialByItem.set(itemId, cur);
          rt.lastUserText = cur;
        }
        return;
      }

      // --- RÖST: transkription färdig ---
      if (msg.type === 'conversation.item.input_audio_transcription.completed' ||
          msg.type === 'conversation.item.input_audio_transcription.done') {
        const itemId = msg.item_id || msg.item?.id || 'unknown';
        const full = (msg.transcript || msg.text || rt.partialByItem.get(itemId) || '').trim();
        if (full) {
          rt.lastUserText = normalizeASR(full); // ⬅️ stavningsfixar
          append(bubble(rt.lastUserText, 'user'));
        }
        rt.dc?.send(JSON.stringify({ type: 'response.create' })); // trigga modell (röst)
        return;
      }

      // visa assisterande text när den dyker upp
      if (msg.type==='conversation.item.created'){
        if (msg.item?.role==='assistant'){
          const parts=msg.item?.content||[];
          for (const p of parts){
            const text = p?.text || p?.output_text;
            if (typeof text === 'string' && text.trim()) append(bubble(text,'assistant'));
          }
        }
      }

      // === FUNKTIONSANROP: fånga skapandet (namn + call_id) ===
      if (msg.type === 'response.function_call.created') {
        const key = msg.call_id || msg.id || 'unknown';
        const prev = rt.calls.get(key) || { argsText: '', call_id: key };
        prev.name = msg.name || prev.name || 'search_manual';
        rt.calls.set(key, prev);
        append(pill(`FUNC CREATED: ${prev.name} (call_id=${key})`));
        return;
      }

      // === FUNKTIONSANROP: delta av arguments ===
      if (msg.type==='response.function_call_arguments.delta'){
        const key = msg.call_id ?? msg.tool_call_id ?? msg.id ?? msg.response_id ?? 'unknown';
        const prev = rt.calls.get(key) || { name: msg.name || 'search_manual', argsText: '', call_id: key };
        prev.argsText += (msg.delta || msg.arguments_delta || '');
        if (msg.name) prev.name = msg.name;
        rt.calls.set(key, prev);
        return;
      }

      // === FUNKTIONSANROP: arguments klara → kör verktyget ===
      if (msg.type==='response.function_call_arguments.done'){
        const key = msg.call_id ?? msg.tool_call_id ?? msg.id ?? msg.response_id ?? 'unknown';
        const tc = rt.calls.get(key) || { name: 'search_manual', argsText: '', call_id: key };

        let args={}; try{ args=JSON.parse(tc.argsText||'{}'); }catch{ args={}; }
        // fallback: om query saknas → senaste transkript
        const effectiveQuery = String(args?.query||'').trim() || String(rt.lastUserText||'').trim();
        if (!args.query && effectiveQuery) args.query = effectiveQuery;

        const shown = (effectiveQuery||'').slice(0,48)+((effectiveQuery||'').length>48?'…':'');
        const toolName = tc.name || 'search_manual';
        append(pill(`TOOL CALL → ${toolName} q="${shown}" (call_id=${tc.call_id})`));

        // kör oavsett namn (defaultar till search_manual)
        runSearchManualTool(tc.call_id, args)
          .catch(err=>append(errorBubble('Tool fel: '+(err?.message||String(err)))));
        return;
      }

      // Svarstext stream klar
      if (msg.type==='response.output_text.done'){
        const text=msg.output_text||msg.text||'';
        if (text?.trim()) append(bubble(text,'assistant'));
        return;
      }
    }

    // ===== Klient-verktyg =====
    async function runSearchManualTool(callId, args) {
      console.log('Tool args:', args);
      const qRaw = String(args?.query||'').trim() || String(rt.lastUserText||'').trim();
      const q = normalizeASR(qRaw); // ⬅️ stavningsfixar för ASR

      if (!q) {
        const fallbackResponse = {
          ok: false,
          snippets: [{
            text: "Jag saknar en fråga att söka på. Säg t.ex. 'Hur gör man sortbyte i OCME?'",
            heading: "Hjälp",
            score: 0
          }],
        };
        rt.dc?.send(JSON.stringify({
          type: 'conversation.item.create',
          item: { type: 'function_call_output', call_id: callId, output: JSON.stringify(fallbackResponse) }
        }));
        rt.dc?.send(JSON.stringify({ type:'response.create' }));
        append(pill('↩︎ function_call_output (fallback) + response.create'));
        return fallbackResponse;
      }

      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 20000);

        const params = {
          query: q,
          k: typeof args?.k === 'number' ? args.k : 5,
          minSim: typeof args?.minSim === 'number' ? args.minSim : 0.3,
          heading: args?.heading || null,
          restrictToHeading: !!args?.restrictToHeading
        };

        const response = await fetch('/api/search-manual', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(params),
          signal: controller.signal
        });
        clearTimeout(timeoutId);

        let data;
        try { data = await response.json(); }
        catch { data = { ok:false, snippets:[], error:'Ogiltigt svar från servern' }; }
        if (!data.snippets) data.snippets = [];

        rt.dc?.send(JSON.stringify({
          type: 'conversation.item.create',
          item: { type: 'function_call_output', call_id: callId, output: JSON.stringify(data) }
        }));
        rt.dc?.send(JSON.stringify({ type:'response.create' }));
        append(pill('↩︎ function_call_output + response.create (snippets: '+(data.snippets?.length||0)+')'));
        return data;
      } catch (error) {
        console.error('Search tool error:', error);
        const errorResponse = {
          ok: false,
          snippets: [{
            text: "Ett tekniskt fel uppstod vid sökning i manualen.",
            heading: "Fel",
            score: 0
          }],
          error: error.toString()
        };
        rt.dc?.send(JSON.stringify({
          type: 'conversation.item.create',
          item: { type: 'function_call_output', call_id: callId, output: JSON.stringify(errorResponse) }
        }));
        rt.dc?.send(JSON.stringify({ type:'response.create' }));
        append(pill('↩︎ function_call_output (error) + response.create'));
        return errorResponse;
      }
    }

    // ===== ASR-normalisering (vanliga fel) =====
    function normalizeASR(s){
      let t = s.toLowerCase();
      // vanliga misshörningar för “sortbyte”
      t = t.replace(/\bsott\b/g, 'sort');
      t = t.replace(/\bsått\b/g, 'sort');
      t = t.replace(/\bsott\s+byte\b/g, 'sortbyte');
      t = t.replace(/\bsått\s+byte\b/g, 'sortbyte');
      // lite fler svenska varianter
      t = t.replace(/\s{2,}/g,' ').trim();
      return t;
    }
  </script>
</body>
</html>
